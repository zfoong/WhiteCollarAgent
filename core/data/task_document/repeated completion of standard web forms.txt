name: Repeated completion of standard web forms
description: Fill the same web form multiple times with different data rows from a data source (e.g., spreadsheet, CSV, document, or simple database export), using a clear mapping between data fields and form inputs. Keep the workflow simple: load data once, test with one row, then loop through remaining rows in GUI mode, logging results.

goal/outcome:
  - A defined and confirmed mapping between data source fields (e.g., columns) and web form inputs.
  - All selected rows from the data source are processed:
    - Each row is either successfully submitted as a web form entry, or
    - Explicitly skipped/failed with a reason recorded.
  - No required form fields are left blank for submitted rows, unless the user explicitly allows blanks.
  - No row is submitted more than once in the same run.
  - A single log file is created in the workspace (e.g., {log_file_path}) listing, for each row:
    - row_index or key value,
    - key identifying fields (e.g., name/email),
    - status (submitted/skipped/error),
    - short message or error detail.
  - The user receives a concise summary of:
    - total rows in the data set,
    - how many were submitted, skipped, or failed,
    - the form URL used,
    - and the log file location.

inputs_params:
  - Required: Form URL, e.g., {form_url}.
  - Required: Data source location and format, e.g.:
    - File path to CSV/TSV, e.g., {data_file_path}.
    - Or exported text file (one row per line) with separators.
    - Or document with clearly structured rows (the agent may suggest exporting to CSV).
  - Required: Mapping between data fields and form inputs, e.g.:
    - {field_mapping} as a mapping from column names to form labels/selectors/order:
      - data column "Name" -> form field "Full Name".
      - data column "Email" -> form field "Email address".
  - Optional: Row selection:
    - All rows, or
    - A subset (e.g., first N rows, specific index range, or rows matching a filter).
  - Optional: Required field list:
    - Which columns must be non-empty for a row to be submitted (others may be optional).
  - Optional: Submission behavior:
    - Stop on first error vs. continue and log errors.
    - Delay between submissions (e.g., {delay_seconds} seconds).
  - Optional: Success indicator for the form:
    - Simple confirmation text expected after submit (e.g., {success_message_snippet}), or
    - Expected URL pattern (e.g., {success_url_pattern}).
  - Optional: Maximum number of rows per run (safety cap), e.g., {max_rows_per_run}.

context:
  reasoning:
    - Keep the number of passes small:
      - One CLI step to load and validate the data source.
      - One GUI “test submission” using a single row to confirm mapping and success detection.
      - One GUI loop to submit the remaining rows.
      - One final summary/logging step.
    - Use CLI via "create and run python script" to:
      - Parse {data_file_path} (prefer CSV-style formats; if more complex, ask user to provide/export CSV).
      - Validate that required columns exist and that at least one row is usable.
      - Optionally pre-filter rows (e.g., skip rows with missing required fields).
      - Write a normalized, simple intermediate file (e.g., {normalized_data_path}) if needed.
    - Use GUI mode for the actual web form interactions:
      - "switch to GUI mode" once before interacting with the browser.
      - For each row:
        - Open {form_url} (or use “submit another response” link if available).
        - Fill fields based on {field_mapping} in a consistent order.
        - Submit the form and wait for the success indicator or an error page.
    - Track per-row outcomes in memory and then write them once to {log_file_path} using "create text file" or a simple Python script.
    - Keep error handling simple:
      - If the form clearly rejects a row, mark it as error with the visible message snippet.
      - If navigation fails or the page cannot load, stop further submissions and report to the user.

  deadline: {time_left} left until deadline {deadline}

  definition_of_done(check during final validation step):
    - Data source was successfully loaded and parsed; required columns are present.
    - The mapping {field_mapping} is clearly defined and was used consistently.
    - The number of attempted submissions equals the number of selected rows (minus any pre-filtered invalid rows).
    - For each selected row, the log contains:
      - row identifier (e.g., row index),
      - status (submitted/skipped/error),
      - short comment.
    - No more than one submission per row in this run.
    - The final "send_message" to the user includes:
      - Number of rows in data,
      - Number of rows submitted successfully,
      - Number skipped or errored,
      - The {form_url},
      - The log file path {log_file_path}.
  avoid:
    - Trying to auto-discover complex selectors or dynamically inspecting HTML beyond what is needed; rely on user-provided mapping when possible.
    - Mutating the original data source file (read-only usage).
    - Overly complex pre-processing (e.g., heavy data cleaning) unless absolutely necessary.
    - Unbounded loops or re-submitting the same row due to ambiguous success detection.
    - Using GUI mode for anything other than browser interaction for the form.

steps:
  name: Confirm form scope, data source, and mapping
  description: Make sure the agent knows which form to fill, which data source to use, which rows to process, and how each column maps to each form field.
  action_instruction: >
    Use the "send_message" action to restate and confirm:
    - Form URL: {form_url}.
    - Data source: file path (e.g., {data_file_path}) and format (CSV/TSV or similar).
    - Which rows to process:
      - All rows, first {n} rows, or a specific range {start_row}–{end_row}.
    - Required columns that must be non-empty for submission (e.g., Name, Email).
    - {field_mapping}: a simple mapping from data columns to form fields (labels or other identifiers).
    - Any success indicator after submission (e.g., a phrase like {success_message_snippet} or a URL pattern {success_url_pattern}).
    - Delay between submissions, if any, e.g., {delay_seconds}.
    - Safety cap {max_rows_per_run} if the dataset is large.
    If any critical information is missing (form URL, data file path, or mapping), use "send_message" with a focused
    question (for example, "Please provide column-to-form mapping like: Name -> 'Full Name', Email -> 'Email address'").
    After clarification, send a short "send_message" summarizing the final parameters so they are clearly recorded.
  validation_instruction: >
    Confirm that:
    - {form_url} is non-empty.
    - {data_file_path} is provided.
    - {field_mapping} includes every required form field.
    - There is a clear definition of which rows to process.
    - There is at least a default success indicator (even if simple, such as "assume success unless an error message appears").
    If any of these are unclear, call "send_message" again. Proceed only when the user has confirmed the core parameters.

  name: Load and validate data source
  description: Use a simple script to load the data rows from the file, check required columns, and determine which rows are usable.
  action_instruction: >
    Use "create and run python script" with a small script that:
    - Reads the file at {data_file_path}.
      - Prefer CSV/TSV parsing (using Python's built-in csv module).
    - Verifies that all required columns in {required_columns} exist in the header.
    - Iterates through the rows and builds a list of usable rows:
      - For each row, check that all required columns are non-empty.
      - If a row is missing required data, mark it as "invalid" in memory for logging later.
    - Applies row selection (e.g., first {n} rows, or {start_row}–{end_row}).
    - Applies safety cap {max_rows_per_run}, if provided, by truncating the list of rows to process and recording that cap was applied.
    - Produces a simple summary to stdout:
      - total rows in file,
      - number of rows selected for processing,
      - number of invalid rows (missing required fields) that will be skipped,
      - any column issues.
    - Optionally, writes a small normalized intermediate representation (e.g., {normalized_data_path}) if it simplifies later access,
      but keep it minimal.
  validation_instruction: >
    Check the action result:
    - Status indicates success (no unhandled exceptions).
    - The script confirms that required columns exist.
    - The number of rows selected for processing is greater than zero; if zero, send a "send_message" explaining that no usable rows were found,
      and ask if the user wants to adjust required columns, row selection, or stop.
    - If {max_rows_per_run} was applied, note this to the user in a "send_message".
    Proceed when there is a clear, non-empty set of rows to submit.

  name: Test single form submission
  description: Submit the form once using a single representative row to validate the mapping and success detection before running the full loop.
  action_instruction: >
    Use "switch to GUI mode" to enable browser interaction.
    Then, using the first usable row in the data:
    - Open the browser to {form_url}.
    - Fill each form field by:
      - Matching data columns in {field_mapping} to visible form fields (by label, placeholder, or a previously agreed selector scheme).
      - Entering the corresponding cell values from the row.
    - Submit the form (click the submit button or equivalent).
    - Wait for the response page to load and:
      - Look for the {success_message_snippet}, or
      - Check that the URL matches {success_url_pattern}, or
      - Confirm that no obvious error message is present (e.g., visible "error" text near fields).
    - Record the outcome in memory for this row as "test_submitted" or "test_error", with a brief note (e.g., "Success message found" or
      "Form reported missing required field").
    If the test indicates a mapping problem (e.g., the page shows validation errors or required fields not filled):
      - Do not continue to full batch.
      - Use "send_message" to:
        - Show the user the error message snippet and explain which field may be mis-mapped.
        - Ask them to adjust {field_mapping} or data, then re-run this step.
  validation_instruction: >
    Confirm that:
    - The form was reached successfully (no navigation error).
    - The result of the test row is clearly known (success or failure) based on the visible page state.
    - If it failed due to mapping or missing data, the issue has been communicated to the user via "send_message".
    Only proceed to full batch submission if the test row is clearly successful (or if the user explicitly instructs to proceed despite minor issues).

  name: Submit remaining rows in batch
  description: Fill and submit the form for each remaining usable row using the validated mapping and success criteria, keeping the loop simple.
  action_instruction: >
    Still in GUI mode:
    - For each remaining usable row (excluding the test row unless the user wants to re-submit it):
      - Navigate to a blank form:
        - Either reload {form_url}, or
        - Use a "Submit another response" or equivalent link if the form provides one.
      - Fill each mapped field using {field_mapping}:
        - Place each value from the row into the corresponding form field.
      - Submit the form.
      - Wait for the response or confirmation page.
      - Check for success as in the test step:
        - {success_message_snippet}, {success_url_pattern}, or absence of obvious error text.
      - Optionally wait {delay_seconds} between submissions if the user requested a delay.
      - For each row, record in memory:
        - row_index (or key),
        - a few key fields (e.g., Name/Email),
        - status: "submitted", "skipped", or "error",
        - note: empty on success or short error/observation.
      - If a serious repeated error occurs (e.g., server error for multiple rows in a row), pause:
        - Use "send_message" to inform the user,
        - Ask if they want to continue or stop.
  validation_instruction: >
    After processing all rows:
    - Ensure that the count of processed rows equals the number of selected usable rows (minus any rows the user asked to skip mid-run).
    - Verify that for each processed row, there is a corresponding in-memory record with status and basic info.
    - If the error rate seems unexpectedly high, note that for the final summary and consider asking the user if they want to retry specific rows.

  name: Overall validate and write submission log
  description: Convert the in-memory records into a simple log file in the workspace and check basic consistency with expectations.
  action_instruction: >
    Use "create and run python script" (back in CLI mode) or a similar simple action to:
    - Take the collected per-row records (row_index, key fields, status, message) from the previous step;
      if needed, the agent can embed these as a literal string or small JSON block in the script input.
    - Write them to a log file in the workspace, e.g., {log_file_path}, in CSV or simple delimited text format.
      Each line should contain at least:
      - row_index,
      - key identifiers (e.g., Name, Email, or another primary field),
      - status (submitted/skipped/error),
      - message.
    - Optionally compute quick counts from these records (submitted, skipped, error) and print them to stdout as a final check.
  validation_instruction: >
    Confirm that:
    - The log file {log_file_path} exists and is non-empty.
    - The number of entries in the log equals the number of rows processed in the GUI step.
    - The counts in the log (submitted/skipped/error) match what the script printed and what was observed during the GUI loop.
    If there is a mismatch, note it in the final user summary and, if necessary, clarify that a few rows may need manual review.

  name: Close task and report to user
  description: Summarize the batch form submission outcome, point to the log file, and set the task status.
  action_instruction: >
    Use "send_message" to provide a concise final summary including:
    - Form URL used: {form_url}.
    - Data source path: {data_file_path}.
    - Total rows in the source and how many were selected for processing.
    - How many rows were:
      - submitted successfully,
      - skipped (e.g., invalid data or user decision),
      - errored (with a brief reason category if possible).
    - Whether a test row was used and if it was part of the final batch.
    - Any important patterns in errors (e.g., "Several rows failed because Email was missing").
    - The path to the log file: {log_file_path}, so the user can inspect or reuse it.
    Based on overall outcome:
    - If submissions were mostly successful and criteria are met, call "mark task completed" with a short message summarizing counts and the log location.
    - If the user chose to stop early (e.g., after test or mid-batch), call "mark task cancel" with a brief explanation.
    - If critical errors (e.g., form unreachable, repeated failures) prevented meaningful completion, call "mark task error" with a short description and log path for partial results.
