name: Search for a certain file or folder
description: Search for a specific file or folder using keywords or simple properties under one or more root directories, using efficient CLI-based actions and minimal steps.

goal/outcome:
  - Clear understanding of what the user wants to find:
    - Target type: file, folder, or both.
    - Root search location(s) {root_paths}.
    - Name keyword(s) or pattern(s) {keyword_pattern}.
    - Optional simple properties (e.g., extension, size, modified time window).
  - A search is executed across the specified root path(s) using name-based matching and optional property filters.
  - A result set is produced listing full paths to matching files/folders, with enough context for the user to recognize the right item(s).
  - Optionally, a result log file is created in the workspace at {result_log_path} with all matches (one per line or as a simple table).
  - The user receives a concise summary:
    - Where was searched.
    - What criteria were used.
    - How many matches were found.
    - A short sample of results and/or the path to the full result log.

inputs_params:
  - Required: Root directory path(s) to search, e.g. {root_paths}.
  - Required: Search keyword or pattern for the name, e.g. {keyword} or wildcard {keyword_pattern} such as "*{keyword}*".
  - Required: Target type:
    - "file" for files only,
    - "folder" for folders only,
    - "both" if user is not sure.
  - Optional: Recursive search flag (true/false) – whether to search subfolders under each {root_path}.
  - Optional: Name filters:
    - Extensions (e.g., ".docx", ".pdf", ".png"),
    - Additional substrings to include or exclude in names.
  - Optional: Simple property filters:
    - Minimum or maximum size (e.g., >= {min_size_mb} MB),
    - Modified time window (e.g., after {modified_after}, before {modified_before}).
  - Optional: Result cap {max_results} to avoid returning an extremely long list.
  - Optional: Whether to write a result log file in the workspace at {result_log_path}.

context:
  reasoning:
    - Keep the flow straightforward: confirm search parameters, run a single efficient search, then present results.
    - Use the dedicated "find file by name" action as the primary way to search by name/pattern under a root directory.
    - For multiple roots, call "find file by name" separately for each, using the same name pattern and recursion flag.
    - If additional property filters (size, modified time) are requested, optionally post-filter the matches in one simple "create and run python script" call instead of changing how the search is performed.
    - Prefer CLI operations; GUI is unnecessary for this task.
    - If results are many, provide a small sample in the message and optionally write a log file with all matches.
    - If nothing is found, clearly state that to the user and suggest narrowing or broadening the search parameters.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - At least one search has been performed under the confirmed {root_paths} using the agreed {keyword_pattern} and flags.
    - Any requested property filters (size/time) have been applied before presenting the final result set.
    - The user sees:
      - How many matches were found.
      - At least a short sample list of full paths.
      - Optionally, a path to a full result log file {result_log_path} if requested.
    - No directories outside of {root_paths} were searched.
    - Any errors encountered (e.g., inaccessible directories) are mentioned briefly to the user.
  avoid:
    - Searching the entire drive without a root path or pattern.
    - Overcomplicating with deep multi-pass logic when a simple name search plus optional filter is enough.
    - Using GUI mode for this task.
    - Hiding errors such as missing or inaccessible directories; mention them briefly and move on or stop as appropriate.

steps:
  name: Confirm search scope and criteria
  description: Clarify exactly what the user wants to find, where to search, and any simple filters to apply.
  action_instruction: >
    Use the "send_message" action to summarize what is needed:
    - Root directory/ies: {root_paths} (e.g., "C:\Users\{user}\Documents", "D:\Projects").
    - Target type: {target_type} ("file", "folder", or "both").
    - Name keyword/pattern: {keyword_pattern} (for example, "*{keyword}*").
    - Recursive search: {recursive_flag} (yes/no).
    - Optional filters:
      - File extensions (e.g., ".docx", ".pdf"),
      - Simple exclude substrings (e.g., "backup", ".git"),
      - Simple size or modified-time filters if user cares.
    Ask the user to confirm or adjust these details. If a critical element is missing (e.g., no root path or keyword),
    use "send_message" with a focused prompt such as "What is the root folder I should start searching from?"
    Once confirmed, send a brief "send_message" summarizing the final search parameters for this task (so they are recorded in the event stream).
  validation_instruction: >
    Ensure:
    - At least one {root_path} string is provided.
    - A non-empty {keyword} or {keyword_pattern} is provided.
    - {target_type} is one of "file", "folder", or "both".
    - {recursive_flag} is known (default to true if the user does not care).
    If any of these are missing or unclear, use "send_message" again and do not proceed until they are confirmed.

  name: Run name-based search
  description: Use the built-in file search action(s) to find matching files/folders by name under the specified root path(s).
  action_instruction: >
    For each {root_path}:
      - Call "find file by name" with:
        - pattern: a wildcard or pattern that includes {keyword_pattern}, such as "*{keyword}*{extension_filter}",
        - recursive: {recursive_flag}.
      - This returns matches under that root according to the pattern.
    Collect all returned matches into a combined list in the task context (event stream).
    If {target_type} is "file", ignore folder-only matches if the action returns both; if "folder", ignore file-only matches.
    If {max_results} is set and the combined list is longer than {max_results}, truncate the list and note this in the later summary.
  validation_instruction: >
    Check the "find file by name" action outputs:
    - Confirm calls succeed (status is OK and there are no critical errors).
    - If all roots fail (e.g., invalid paths), use "send_message" to explain that no valid roots were found and ask the user to correct {root_paths}; if still invalid, consider "mark task error".
    - If zero matches are found:
      - Use "send_message" to report that nothing matched {keyword_pattern} under {root_paths} and ask if the user wants to adjust the pattern, root, or filters.
      - If the user decides not to adjust, the task can still be completed as "search performed, no matches."

  name: Apply optional property filters (size/time/type)
  description: Narrow down the raw matches list using simple property criteria if requested by the user.
  action_instruction: >
    If the user requested additional property filters (size, modified time), use "create and run python script" with a short script that:
    - Receives the raw list of paths (e.g., embedded into the script or re-derived with a simple pattern).
    - For each path:
      - Check whether it refers to a file or a directory, and either keep or exclude based on {target_type}.
      - If size filter is specified, use os.path.getsize() and compare against {min_size_bytes}/{max_size_bytes}.
      - If modified time filter is specified, use os.path.getmtime() and compare against {modified_after}/{modified_before}.
    - Build a filtered list of paths that satisfy all conditions.
    - Print summary counts (before/after filtering) to stdout.
    - Optionally write the final filtered list to a simple text file at {result_log_path} if logging was requested.
    If no property filters were requested, skip this step and treat the raw matches from "find file by name" as the final results.
  validation_instruction: >
    If the filter script was used:
    - Check that it completed successfully (no unhandled exceptions).
    - Verify that stdout reports:
      - Total raw matches,
      - Total filtered matches.
    - If the result set becomes empty after filtering, note this in a "send_message" so the user understands that matches existed by name but did not meet the additional criteria.
    If no filters were used, validation is just confirming that the raw match list exists.

  name: Overall validate search results
  description: Ensure the final result list and optional log align with the definition_of_done in a simple, direct way.
  action_instruction: >
    Determine the final result set (either the filtered list if filters were applied, or the raw match list otherwise).
    If logging was requested:
      - Use "create text file" to write a plain text or CSV file at {result_log_path}, with one path per line, or columns such as:
        - path,{type},{size_bytes},{modified_time} if easily available.
    Confirm that:
      - The final result list is defined (even if empty).
      - If {result_log_path} was requested, the log file creation action reports success.
    No additional scans are needed; rely on the direct outputs of "find file by name" and any filter script.
  # No extra validation_instruction beyond these simple checks is needed.

  name: Close task and report to user
  description: Present the search results to the user, optionally link to a full log, and mark the task status.
  action_instruction: >
    Use "send_message" to give a concise summary:
    - Root path(s) searched: {root_paths}.
    - Target type: {target_type}.
    - Name keyword/pattern: {keyword_pattern}.
    - Whether recursion was used.
    - If property filters were applied, mention them briefly (e.g., "files >= {min_size_mb} MB, modified after {modified_after}").
    - Number of matches found, and if truncated, indicate that only the first {max_results} are shown.
    - Show a small sample of full paths (e.g., first 5–10 results) inline.
    - If a result log file was created, provide its path {result_log_path}.
    If the search produced at least some results or conclusively no results:
      - Call "mark task completed" with a short message summarizing the outcome.
    If the user chose to stop because of invalid roots or parameters and did not want to continue:
      - Call "mark task cancel" with a brief reason.
    If repeated errors (e.g., permission issues or failures in the search actions) prevented any meaningful search:
      - Call "mark task error" with a short explanation and any partial info/log paths if available.
