name: Log file collection and rotation
description: Gather log files from specified locations, rotate them according to a simple retention policy, and archive old logs to free disk space while keeping recent logs readily available.

goal/outcome:
  - Log files under the specified locations {log_root_paths} are discovered according to clear patterns (e.g., *.log, *.txt, specific names).
  - An explicit rotation policy is applied, such as:
    - Size-based rotation (e.g., rotate when file > {max_log_size_mb} MB), and/or
    - Age-based rotation (e.g., rotate/archive logs older than {max_log_age_days} days).
  - Active logs remain in place under predictable names (e.g., {log_name}.log) with rotated files stored alongside them (e.g., {log_name}.log.1, {log_name}.log.2) or compressed.
  - Older or rotated logs are either:
    - Archived under {archive_root} (optionally compressed), and/or
    - Deleted when exceeding a simple retention limit (e.g., keep {retention_count} most recent or keep last {retention_days} days).
  - A single log/manifest file is created in the workspace (e.g., {log_rotation_manifest}) listing each processed log file, action (rotated/archived/deleted/skipped), and any errors.
  - The user receives a concise summary describing the directories processed, the policy applied, counts of files rotated/archived/deleted, and where the manifest is stored.

inputs_params:
  - Required: One or more log root directories:
    - Example: {log_root_1}, {log_root_2}, etc.
  - Required: Rotation/retention policy:
    - Size-based threshold in MB, e.g., {max_log_size_mb} (rotate logs larger than this).
    - And/or age-based threshold in days, e.g., {max_log_age_days} (treat logs older than this as candidates for archival/deletion).
    - Retention count {retention_count} or retention days {retention_days} for rotated/archived logs.
  - Required: Archive destination directory {archive_root} for rotated/old logs (can be under the workspace or another path).
  - Optional: Log selection patterns:
    - File extensions or glob-like patterns, e.g., ["*.log", "*.out"].
    - Specific log names to include or exclude.
  - Optional: Cleanup mode for old archives:
    - "archive_only" (never delete, just rotate/archive).
    - "delete_old" (delete archives older than {retention_days} days or exceeding {retention_count}).
  - Optional: Compression preference:
    - Whether to compress rotated logs (e.g., .zip as default).
    - Archive file naming convention, e.g., {log_name}_{date_time}.zip.
  - Optional: Dry-run flag:
    - {dry_run} = true: only report what would be rotated/archived/deleted, no changes.
  - Optional: Safety cap:
    - Maximum number of files to process, {max_files}.
    - Optional maximum total size of logs to manipulate, {max_total_size_mb}.

context:
  reasoning:
    - Keep the workflow simple: confirm policy, run one efficient script to scan and apply rotation/archival, then report.
    - Prefer using "create and run python script" to:
      - Traverse {log_root_paths}.
      - Identify log files based on patterns, size, and age.
      - Apply a straightforward rotation scheme per log family (rename/roll older logs, optionally compress or move to {archive_root}).
      - Enforce retention by deleting or archiving only beyond the configured limits.
      - Write a manifest {log_rotation_manifest} with per-file actions.
    - Use "create folder" once to ensure {archive_root} exists (if needed).
    - Use dry-run only when the user asks for it or seems unsure; otherwise go directly to a single rotation pass.
    - Avoid excessive rescans: scanning and acting in the same script is acceptable for simplicity and efficiency.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - For every log root in {log_root_paths}:
      - Log files matching the patterns have been considered once.
      - Logs exceeding size/age thresholds have been rotated/archived/deleted according to the policy.
    - No non-log files or excluded paths have been modified.
    - No active log file was deleted when it should have been rotated.
    - The number of rotated/archived/deleted/skipped files is recorded in {log_rotation_manifest}.
    - The user has received a summary message that includes:
      - The roots {log_root_paths}.
      - The rotation and retention rules applied (size/age, retention type).
      - Counts per action (rotated/archived/deleted/skipped).
      - Path to {log_rotation_manifest} and any archive directories used.
  avoid:
    - Rotating or deleting logs outside the specified {log_root_paths}.
    - Complex backup/restore flows beyond simple archiving to {archive_root}, unless explicitly requested.
    - Using GUI mode; CLI/scripts are sufficient.
    - Multiple passes or over-engineered mapping files when a single script with a manifest is enough.
    - Deleting logs that the user expects to keep (e.g., current active logs or recent archives) without clear policy confirmation.

steps:
  name: Confirm log scope and rotation policy
  description: Clarify which logs to manage, where they are located, and what rotation/retention rules to apply.
  action_instruction: >
    Use the "send_message" action to restate and confirm:
      - The log root directories {log_root_paths} to scan (e.g., {log_root_1}, {log_root_2}).
      - The log patterns to include (e.g., ["*.log", "*.out"]) and any patterns or paths to exclude.
      - The rotation triggers:
        - Size threshold in MB, e.g., {max_log_size_mb}.
        - Age threshold in days, e.g., {max_log_age_days}, if any.
      - The retention policy:
        - Keep latest {retention_count} rotated or archived logs per log name, OR
        - Keep logs not older than {retention_days} days.
      - The archive destination directory {archive_root}, and whether it can be created if missing.
      - Cleanup mode for very old archives:
        - "archive_only" or "delete_old".
      - Compression preference (e.g., "zip" archives) and naming pattern such as {log_name}_{date_time}.zip.
      - Whether this run is a dry-run ({dry_run} = true/false).
      - Any safety caps (e.g., {max_files} files, {max_total_size_mb} MB).
    If any critical detail (roots, thresholds, retention, or archive location) is missing or unclear, use "send_message"
    with a short, focused question (for example, "Should we delete archives older than {retention_days} days, or keep all archives?").
    Once clarified, send a brief "send_message" summarizing the final parameters so they are explicit in the task history.
  validation_instruction: >
    Confirm that:
      - At least one root directory {log_root} is specified.
      - At least one rotation trigger is configured (size, age, or both).
      - A retention policy is defined (by count or by days).
      - An archive destination {archive_root} is known (even if in "archive_only" mode).
      - Dry-run vs actual run is clearly decided.
    If any of these is missing, use "send_message" again. Proceed only after the user confirms the configuration.

  name: Ensure archive directory exists
  description: Prepare the archive destination location so that rotated logs can be moved or compressed there without errors.
  action_instruction: >
    If {archive_root} does not clearly exist yet, call "create folder" with:
      - path: {archive_root_parent}
      - folder_name: {archive_root_name}
    or with a combined path if {archive_root} is a single full path.
    After that, you can optionally use "list folder" on {archive_root} to confirm it is accessible.
  validation_instruction: >
    Validate that:
      - "create folder" or "list folder" returns a success status for {archive_root}.
      - No error message indicates permission or path issues.
    If archive creation/access fails, notify the user via "send_message" and ask whether to:
      - Use a different {archive_root}, or
      - Run in a mode that does not archive (if acceptable).
    Do not proceed to rotation until a usable archive location is available or the user explicitly agrees to skip archiving.

  name: Scan logs and apply rotation/archival in one script
  description: Traverse the specified log roots, identify log files matching the policy, and apply rotation/archival/deletion in a single efficient pass, optionally as a dry-run.
  action_instruction: >
    Use "create and run python script" with a script that:
      - Accepts:
        - log_root_paths = {log_root_paths}
        - include_patterns = {log_patterns}
        - exclude_paths_or_patterns = {exclude_patterns}
        - max_log_size_mb = {max_log_size_mb}
        - max_log_age_days = {max_log_age_days}
        - retention_count = {retention_count} and/or retention_days = {retention_days}
        - archive_root = {archive_root}
        - cleanup_mode = {cleanup_mode} ("archive_only" or "delete_old")
        - compression_type = {compression_type} (e.g., "zip")
        - dry_run = {dry_run}
        - safety caps: max_files = {max_files}, max_total_size_mb = {max_total_size_mb}
        - manifest_path = {log_rotation_manifest}
      - For each root in log_root_paths:
        - Verify it exists and is a directory; otherwise note the issue in stdout and continue.
        - Walk the directory tree (os.walk):
          - Skip excluded paths early if they match exclude_patterns.
          - For each file matching include_patterns:
            - Compute size (bytes) and modification time.
            - Decide if it is a candidate for rotation/archival based on max_log_size_mb and/or max_log_age_days.
            - Track counts and cumulative size; if safety caps are exceeded, stop processing and record this in stdout.
      - For each log "family" (base log name and its rotated variants):
        - Sort existing rotated files by age or numeric suffix.
        - Apply rotation:
          - If dry_run is True:
            - Do not modify files; just record for each what would happen:
              - "would_rotate", "would_archive", "would_delete".
          - If dry_run is False:
            - For active logs exceeding thresholds:
              - Rename or copy current log to a rotated name pattern, such as {log_name}.log.{n}.
              - Optionally compress rotated files into {archive_root} under a name like {log_name}_{date_time}.zip.
            - Enforce retention:
              - If cleanup_mode == "delete_old":
                - Delete rotated or archived entries older than retention_days or beyond retention_count.
              - If cleanup_mode == "archive_only":
                - Keep rotated/archived files but do not delete beyond retention; only rotate/collect.
      - For every file considered, write a line to the manifest at {log_rotation_manifest} containing:
        - log_path, size_bytes, age_days, action ("rotated", "archived", "deleted", "skipped", "would_*"), error_message (empty if none).
      - At the end, print to stdout:
        - Total log roots processed.
        - Total candidate files.
        - Total size of candidates and of processed logs (bytes or MB).
        - Counts per action (rotated, archived, deleted, skipped, would_*).
        - Path to {log_rotation_manifest}.
  validation_instruction: >
    Check the "create and run python script" result:
      - Status indicates success (no unhandled exceptions).
      - stdout mentions:
        - Total candidates.
        - Per-action counts.
        - The manifest path {log_rotation_manifest}.
    If zero candidates were found, send a short "send_message" explaining that no logs matched the current policy and
    ask if the user wants to adjust thresholds or stop.
    If safety caps were triggered, ensure this is clearly noted for the final summary.

  name: (Optional) Execute actual rotation after dry-run
  description: If the user requested a dry-run first, optionally rerun the script with the same parameters but dry_run set to false.
  action_instruction: >
    If {dry_run} was true in the previous step:
      - Use "send_message" to tell the user:
        - Dry-run completed.
        - Candidate counts, approximate total size, and location of {log_rotation_manifest}.
        - Ask if they want to proceed with actual rotation and archival using the same policy.
      - If the user confirms:
        - Rerun the same "create and run python script" with dry_run set to false, using the same parameters.
      - If the user declines:
        - Make it clear that no files have been changed.
  validation_instruction: >
    For the second run:
      - Validate as before: script status is success, counts and manifest path are reported.
      - If user declines, there is nothing more to validate beyond confirming that it stayed a dry-run.

  name: Overall validate log rotation task
  description: Perform a minimal final check against the definition_of_done using the scriptâ€™s summary and manifest.
  action_instruction: >
    Use "shell view" or a short "create and run python script" to:
      - Open {log_rotation_manifest}.
      - Count total lines (excluding header).
      - Count entries per action ("rotated", "archived", "deleted", "skipped", "would_*").
    Confirm:
      - These counts match the summary reported by the script.
      - There are no unexpected statuses.
    No extra directory rescans are necessary unless the counts look obviously wrong or errors dominate.
  # Additional validation_instruction is not needed beyond these simple checks.

  name: Close task and report to user
  description: Summarize what was done (or would be done in dry-run), provide the manifest location, and mark task status.
  action_instruction: >
    Use "send_message" to provide a short summary including:
      - The log roots {log_root_paths} that were processed.
      - Whether this was a dry-run or actual rotation.
      - The key rotation/retention rules:
        - Size threshold {max_log_size_mb}, age threshold {max_log_age_days}, retention {retention_count}/{retention_days}.
        - Cleanup mode {cleanup_mode} and compression preference {compression_type}, if any.
      - Counts of logs rotated, archived, deleted, skipped, and any "would_*" actions for dry-run.
      - Approximate total size of processed or candidate logs.
      - The path to {log_rotation_manifest} and archive directory {archive_root}.
    If it remained a dry-run at the user's request:
      - Explicitly state that no files were changed.
    For a successful actual rotation:
      - Call "mark task completed" with a short message summarizing the key numbers and manifest location.
    If the user canceled instead of proceeding with actual rotation:
      - Call "mark task cancel" with the reason.
    If the script failed repeatedly or could not access important directories such that the task could not reasonably be completed:
      - Call "mark task error" with a brief description and the path to {log_rotation_manifest} if it exists.
