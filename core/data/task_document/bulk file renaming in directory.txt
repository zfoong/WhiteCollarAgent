name: Bulk file renaming in a directory tree
description: Rename all files in one or more folders (optionally including subfolders) according to simple naming rules such as adding prefixes/suffixes, replacing characters/substrings, or appending timestamps. Use a single efficient pass over the directory tree and minimal supporting actions.

goal/outcome:
  - All targeted files in the specified directory tree(s) are renamed according to the user-defined rules (prefix/suffix, replacements, optional timestamp).
  - File extensions are preserved unless the user explicitly asks to change them.
  - No unexpected directories or files outside the specified roots are touched.
  - Name collisions are handled in a predictable way (e.g., appending a counter) without silently overwriting files.
  - A single log file is created in the workspace mapping old paths to new paths with per-file status.
  - The user receives a concise summary of what was renamed, how many files were affected, and where the log file is stored.

inputs_params:
  - Required: One or more root directory paths where files should be renamed.
  - Required: Naming rules, such as:
    - Prefix to add.
    - Suffix to add.
    - Simple replacements (e.g., " " -> "_", "-" -> "_", or specific substrings).
    - Whether to append a timestamp and its format (e.g., YYYYMMDD, YYYYMMDD_HHMM).
  - Optional: Whether to include subdirectories (recursive: true/false).
  - Optional: Simple include patterns (e.g., by extension: ".jpg", ".txt") and/or exclude patterns (e.g., ".sys", ".tmp").
  - Optional: Collision handling rule (e.g., append counter vs. skip).
  - Optional: Dry-run flag (preview mapping only, no actual renames).
  - Optional: Maximum number of files to process (safety cap).

context:
  reasoning:
    - Keep the workflow simple and direct: gather parameters, scan directories, compute new names, perform renames in one script, and log results.
    - Prefer CLI-based operations via "create and run python script" for traversal and renaming; this avoids GUI overhead.
    - Perform a straightforward recursive or non-recursive walk over the selected roots and filter files by simple rules (extensions, basic patterns).
    - Compute new file names by applying the naming rules in a fixed order (replacements → prefix/suffix → optional timestamp) while preserving extensions.
    - Handle collisions locally for each directory using a counter-based suffix to avoid overwrites.
    - Immediately log each attempted rename with success/failure to a single text/CSV file in the workspace.
    - Only run a dry-run mapping when explicitly requested; otherwise, go straight to actual renaming.
    - Use simple checks at the end (counts and log inspection) to confirm that the operation ran as expected.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - Every file selected under the given root(s) has either:
      - Been renamed according to the rules, or
      - Been skipped with a reason recorded in the log (e.g., collision or error).
    - No files outside the specified root paths were renamed.
    - No file was silently overwritten due to a collision.
    - A log file exists in the workspace containing, at minimum: original path, new path, and status for each file.
    - The user has received a short summary message including:
      - Root paths.
      - Rules applied.
      - Total files processed, renamed, and skipped.
      - Path to the log file.
  avoid:
    - Introducing extra phases such as backup/restore or complex mapping previews unless explicitly requested.
    - Performing multiple redundant scans when a single traversal plus simple checks is sufficient.
    - Using GUI mode for this task; CLI is enough.
    - Overly complex pattern languages; stick to simple, clearly described rules.
    - Renaming system or hidden files unless the user explicitly wants them included.

steps:
  name: Confirm scope and rules
  description: Ensure all necessary information to perform the renaming is clearly defined and confirmed by the user.
  action_instruction: >
    Use the "send_message" action to briefly list the required inputs and show the current understanding of the request:
    - Root directory path(s).
    - Whether to include subfolders.
    - Naming rules (prefix, suffix, simple replacements, timestamp yes/no and format).
    - Optional filters (include extensions and/or simple exclude patterns).
    - Collision handling choice (append counter vs. skip).
    - Whether a dry-run preview is desired or should proceed directly with renaming.
    Ask the user to confirm or correct any missing or ambiguous parts. If a critical detail remains unclear
    (e.g., what to do with collisions, or whether to preserve extensions), use the "send_message" action with a focused
    question. Once the user answer is received, restate the final parameters in a short "send_message" so they are explicit
    in the task history.
  validation_instruction: >
    Check that:
    - At least one valid-looking root path string is provided.
    - There is a non-empty naming rule set (at least one of prefix, suffix, replacement, or timestamp).
    - Recursion preference is decided.
    - A default collision strategy is chosen (if the user does not care, use "append counter").
    If any of these are missing, call "send_message" again. Only proceed when the user has clearly confirmed the final rules.

  name: Scan directories and collect target files
  description: Verify the root directories exist and collect the list of files to be processed, using a single efficient traversal.
  action_instruction: >
    Use "create and run python script" with a small script that:
    - Takes as input:
      - The root path list.
      - The recursion flag.
      - Simple include and exclude filters (e.g., by extension).
      - The maximum file count (if any).
    - For each root path:
      - Check that the directory exists; if it does not, print a clear message to stdout for that root.
      - Walk the directory (using os.walk when recursive, or a simple listdir for non-recursive).
      - Apply include/exclude rules to each file.
      - Append the absolute path of each target file to an in-memory list.
    - At the end:
      - Print to stdout:
        - Total roots found.
        - Total candidate files.
      - Optionally write the file list to a temporary text file in the workspace if convenient, but do not overcomplicate.
    Capture stdout/stderr from the action output for quick diagnostics.
  validation_instruction: >
    Check the script status in the action output:
    - It must indicate success (no unhandled exceptions).
    - Confirm at least one root directory was valid; if any root is invalid, send a "send_message" telling the user which root(s) were skipped and decide whether to continue or cancel.
    - If zero files are found, send a concise "send_message" explaining that no files matched the filters and ask the user if they want to adjust filters or stop.
    Proceed only when there is a clear, non-empty set of target files agreed upon.

  name: Rename files in one pass and log results
  description: Apply the naming rules to each collected file and perform renames in a single script, logging all outcomes.
  action_instruction: >
    Use "create and run python script" again with code that:
    - Receives:
      - The list of target file paths (passed directly in code or re-collected in the same script for simplicity).
      - The naming rules (prefix, suffix, replacements, timestamp format, recursion already handled).
      - The collision strategy (append counter or skip).
      - A dry_run flag.
      - The path for a log file in the workspace (e.g., "bulk_rename_log_{timestamp}.csv").
    - For each file:
      - Split the path into directory, base name, and extension.
      - Apply replacements to the base name (e.g., replace spaces with underscores).
      - Add prefix/suffix as specified.
      - Append a timestamp if requested (using datetime.now().strftime with the agreed format).
      - Preserve the original extension unless the user explicitly requested otherwise.
      - Build the proposed new path in the same directory.
      - Check for collisions:
        - If a file with the new name already exists:
          - If strategy is "append counter", append "_1", "_2", etc. until a free name is found.
          - If strategy is "skip", leave the file unchanged and mark status as "skipped_collision".
      - If dry_run is true, do not rename; just record what would happen.
      - If dry_run is false, call os.rename to perform the rename and catch any exceptions.
      - For each file, write a log line containing:
        - original_path, new_path (or same as original if skipped), status ("renamed", "skipped_collision", "error"), and a short error message if any.
    - At the end of the script:
      - Print to stdout a small summary: total files processed, renamed, skipped, and errored, plus the log file path.
  validation_instruction: >
    Inspect the action output:
    - Ensure the script finished without unhandled exceptions.
    - Confirm that a log file path is mentioned in stdout and that its location is reasonable.
    - Note the counts of renamed, skipped, and error cases from stdout.
    If the script failed globally (e.g., a coding error or permission error), explain briefly to the user with "send_message"
    and decide whether to retry with a corrected script or "mark task error" if it cannot reasonably be fixed.

  name: Overall validate renaming task
  description: Check the results against the definition_of_done using the log and summary output; ensure no extra validation passes beyond what is necessary.
  action_instruction: >
    Use the information from the rename script’s stdout and the log file to perform a simple, final validation:
    - If the operation was a dry-run:
      - Confirm with the user (via "send_message") whether they want to rerun without dry_run; if so, repeat the previous step with dry_run=false.
    - If renaming was actually performed:
      - Optionally use "create and run python script" or "shell view" to:
        - Open the log file.
        - Count how many rows have status "renamed", "skipped_collision", "error".
      - Verify that:
        - The number of processed files in the log matches the number reported earlier.
        - There are no unexpected statuses.
      - If the error count is non-zero, prepare to mention this in the final summary (no extra passes unless errors are severe and the user requests retries).
    If the results clearly satisfy the definition_of_done (no silent overwrites, log exists, and counts are consistent), proceed to reporting. Otherwise, briefly explain the discrepancies to the user and either retry specific parts (if simple) or plan to "mark task error" if the situation is not recoverable within this task.

  name: Close task and report to user
  description: Summarize the outcome, provide the log file location, and mark the task status.
  action_instruction: >
    Use "send_message" to send a concise final summary including:
    - The root directory path(s) processed.
    - The naming rules actually applied (prefix, suffix, key replacements, timestamp usage).
    - Whether it was a dry-run or a real rename.
    - Counts of files processed, renamed, skipped (especially due to collisions), and errored.
    - The path to the log file in the workspace so the user can inspect or reuse it.
    If the operation was a dry-run and the user wants to stop there, state clearly that no files were changed.
    If the renaming completed to a reasonable standard:
    - Call "mark task completed" with a short message summarizing success and pointing to the log.
    If the user decided to cancel mid-way:
    - Call "mark task cancel" with the reason (e.g., user changed requirements).
    If the task could not be completed due to unresolvable errors:
    - Call "mark task error" with a brief but clear description of what failed and where the log can be found for inspection.
