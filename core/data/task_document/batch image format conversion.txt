name: Batch image format conversion
description: Convert large sets of images in one or more folders from their current formats (e.g., PNG, JPEG, WEBP) into a single target format using an efficient CLI-based batch process. Preserve or mirror directory structure as needed, avoid unnecessary re-encoding, and keep logging simple.

goal/outcome:
  - All selected images under {source_directory_list} are converted to the specified target format {target_format} (e.g., "jpeg", "png", "webp").
  - File extensions and encodings of the output images match the chosen {target_format} (e.g., .jpg for JPEG, .webp for WEBP).
  - The output images are written to {output_directory} (or in-place if explicitly requested), optionally mirroring the source subfolder structure.
  - Original files are preserved or deleted according to the user’s choice (default: preserve originals).
  - No files outside the agreed scope (paths/patterns) are processed.
  - A single log file {log_file_path} is created in the workspace mapping source paths, output paths, status, and any error messages.
  - The user receives a short summary including counts of processed/converted/skipped files, total approximate input size, target format, output location, and log path.

inputs_params:
  - Required: One or more source root directories, e.g., {source_directory_list}, where images are located.
  - Required: Target image format {target_format} (e.g., "jpeg", "png", "webp").
  - Required: Output location policy:
    - "separate_output_directory": write converted files to {output_directory} while mirroring the source subfolders.
    - "in_place": replace or add converted files next to originals in {source_directory_list}.
  - Optional: Original file retention policy:
    - "keep_originals" (default).
    - "delete_after_successful_conversion".
  - Optional: Recursion flag {recursive} (true/false) to include subdirectories.
  - Optional: Include filters:
    - File extensions to process, e.g., [".png", ".jpg", ".jpeg", ".webp"].
    - Minimum/maximum resolution or size thresholds if the user cares.
  - Optional: Exclude filters:
    - Paths or subfolders to skip (e.g., {exclude_paths}).
    - Extensions not to touch (e.g., ".svg").
  - Optional: Quality/compression settings for {target_format}, e.g.:
    - JPEG quality (0–100).
    - WEBP quality or lossless flag.
  - Optional: Dry-run flag {dry_run} (True/False) to only plan and log what would be converted.
  - Optional: Safety limits:
    - {max_files} maximum number of images to process.
    - {max_total_bytes} maximum total input size to process.

context:
  reasoning:
    - Use a small number of efficient CLI-based actions; prefer a single "create and run python script" to scan, convert, and log in one pass, based on user-confirmed parameters.
    - In the Python script, use only standard library plus any needed library installed inside the script (for example, install Pillow via pip if not present) to open, convert, and save images.
    - Traverse {source_directory_list} with os.walk when {recursive} is true; otherwise, only process the top-level directory.
    - Filter files by extension and optional size/resolution rules to keep the candidate set focused.
    - For each candidate file:
      - Build the corresponding output path in {output_directory} or in-place.
      - Avoid overwriting existing files unless the user explicitly agrees; when overwriting is not allowed, use a simple suffix (e.g., {base_name}_converted.{ext}) or skip.
      - Convert only when needed (e.g., if the file is already in {target_format} and the user prefers to skip re-encoding).
    - Log every attempted conversion with source path, target path, status (converted/skipped/error), and a brief error message when applicable.
    - Use dry-run only when requested; otherwise, go directly to actual conversion to avoid extra passes.
    - Perform minimal but sufficient validation at the end: check the script status, file counts, and that the log exists at {log_file_path}.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The task has produced:
      - Either a dry-run log listing which images would be converted, or
      - A conversion log showing actual converted files, skipped files, and errors.
    - The number of processed entries in {log_file_path} matches the script’s reported counts.
    - No files outside {source_directory_list} are listed as processed.
    - No unexpected overwrites occurred (any overwrite behavior matches the user’s policy).
    - A final message has been sent to the user summarizing:
      - Source roots.
      - Target format {target_format}.
      - Output location {output_directory} and structure.
      - File counts per status (converted, skipped, error).
      - Approximate total size of converted input files.
      - Path to {log_file_path}.
  avoid:
    - Using GUI mode or manual per-file operations; rely on a single batch script.
    - Installing heavy or unnecessary dependencies beyond what is needed for image conversion.
    - Repeatedly re-scanning directories; use one traversal per run.
    - Modifying originals without clear confirmation of retention policy.
    - Overly complex quality/resizing logic; keep settings simple and explicit.

steps:
  name: Confirm conversion scope and settings
  description: Make sure the agent has clear, user-confirmed parameters for what to convert, to which format, where to store outputs, and how to treat originals.
  action_instruction: >
    Use the "send_message" action to briefly restate and confirm:
    - Source root paths: {source_directory_list}.
    - Whether to include subdirectories ({recursive}: true/false).
    - Target format {target_format} (e.g., "jpeg", "png", "webp").
    - Output policy:
      - "separate_output_directory" with {output_directory}, or
      - "in_place" next to originals.
    - Original retention:
      - "keep_originals" (default) or
      - "delete_after_successful_conversion".
    - Include filters (extensions such as .png, .jpg, .jpeg, .webp) and any excludes (paths or extensions).
    - Any basic quality settings for {target_format} (e.g., JPEG quality or WEBP quality).
    - Dry-run vs actual conversion ({dry_run}).
    - Optional safety caps {max_files} and {max_total_bytes}.
    Ask the user to confirm or correct these. If any critical item is missing or unclear
    (for example, {target_format} or {output_directory} for separate output), use "send_message"
    with a focused question. Once clarified, send a concise "send_message" summarizing the final agreed parameters so they are recorded.
  validation_instruction: >
    Confirm that:
    - {source_directory_list} is non-empty and contains at least one path string.
    - {target_format} is specified and understood (e.g., "jpeg", "png", "webp").
    - Output policy is decided and, if "separate_output_directory" is used, {output_directory} is provided.
    - Retention policy is known; if not specified, default to "keep_originals".
    - Dry-run vs actual conversion is explicitly decided.
    If any of these are missing, call "send_message" again. Proceed only after the user confirms the final configuration.

  name: Run batch conversion script
  description: Use a single Python script to scan source directories, convert images, and write a log describing what happened for each file.
  action_instruction: >
    Use "create and run python script" with code that:
    - Defines parameters inline based on the confirmed values:
      - source_roots = {source_directory_list}
      - target_format = {target_format}
      - output_policy = {"separate_output_directory" or "in_place"}
      - output_root = {output_directory} (if separate_output_directory)
      - recursive = {recursive}
      - keep_originals = (True/False based on retention policy)
      - include_exts = {include_extensions}  # e.g., [".png", ".jpg", ".jpeg", ".webp"]
      - exclude_paths = {exclude_paths}
      - quality_settings = {quality_settings}  # optional dict
      - dry_run = {dry_run}
      - max_files = {max_files} or None
      - max_total_bytes = {max_total_bytes} or None
      - log_file_path = {log_file_path}
    - Inside the script:
      - Import required modules (os, sys, time, datetime, pathlib, shutil, csv, etc.).
      - Attempt to import Pillow (PIL). If unavailable, install it via pip using subprocess, then import again.
      - Initialize counters: total_candidates, converted_count, skipped_count, error_count, total_input_bytes.
      - Prepare {log_file_path} for CSV or delimited text with header:
        - source_path, output_path, status, message, size_bytes.
      - For each source_root:
        - Check that it exists and is a directory; if not, optionally print a warning and continue.
        - Walk the directory:
          - Use os.walk if recursive is True; else only process the top-level directory.
          - Skip subdirectories whose paths match any {exclude_paths}.
          - For each file:
            - Check extension against include_exts; skip non-matching files.
            - Gather file size and update total_input_bytes.
            - Apply safety caps: if max_files or max_total_bytes would be exceeded, stop further processing.
            - Build the intended output path:
              - If output_policy is "separate_output_directory", create corresponding subfolder structure under {output_directory}.
              - If "in_place", construct the new filename in the same directory.
              - Use a consistent extension for {target_format} (e.g., ".jpg", ".png", ".webp").
            - If file is already in {target_format} and user prefers to skip re-encoding, mark status "skipped_same_format" and log it.
            - If dry_run is True:
              - Log status "would_convert" with the output path, but do not modify the file system.
            - If dry_run is False:
              - Open the source image with PIL.Image.
              - Apply simple conversion:
                - Convert mode if necessary (e.g., to "RGB" for JPEG).
                - Apply quality options for {target_format} if provided.
              - Ensure output directory exists (os.makedirs).
              - If an output file already exists at that path:
                - Append a simple suffix (e.g., "_1", "_2") to avoid overwrite, unless user explicitly allowed overwrite.
              - Save the converted file to output_path.
              - If keep_originals is False and save succeeded, delete the original file.
              - Log status "converted" or "error" if any exception occurred.
      - After looping:
        - Close the log file.
        - Print to stdout a summary with:
          - total_candidates, converted_count, skipped_count, error_count, total_input_bytes (in bytes).
          - the log_file_path.
    Capture status, stdout, and stderr from "create and run python script" output for use in later steps.
  validation_instruction: >
    Validate the script run by checking:
    - The action status is success (no unhandled exception at the top level).
    - stdout contains a clear summary with counts and the {log_file_path}.
    - If total_candidates is zero, send a "send_message" to inform the user that no images matched the filters and ask if they want to adjust parameters or stop.
    - If max_files or max_total_bytes limits were reached, make sure this is mentioned in the script summary so you can relay it to the user.
    Proceed to final validation and reporting only if the script completed in a reasonable way (even with some per-file errors).

  name: Quick log-based validation
  description: Perform a minimal, log-driven check to ensure counts are consistent and the log is usable, without extra directory scans.
  action_instruction: >
    Use "shell view" or a small follow-up "create and run python script" to:
    - Confirm that {log_file_path} exists and is readable.
    - Count the total number of log data lines (excluding header, if any).
    - Count how many lines have statuses like "converted", "would_convert", "skipped_same_format", and "error".
    - Compare these counts with the summary reported in the previous step’s stdout:
      - total_candidates should match the log entries.
      - converted_count and error_count should be consistent.
    If there is a major mismatch (e.g., log has many fewer lines than expected), send a short "send_message" to the user describing the discrepancy and either:
      - Rerun the conversion step (if simple and safe), or
      - Explain the limitation and plan to "mark task error" if accurate logging cannot be guaranteed.
    If counts line up and there is no sign of a systemic problem, move on to final reporting.
  # No separate validation_instruction needed; these checks are the validation.

  name: Close task and report to user
  description: Summarize the batch conversion results, provide key details and log location, and mark the task status accordingly.
  action_instruction: >
    Use "send_message" to provide a concise final summary including:
    - Task name: Batch image format conversion.
    - Source roots: {source_directory_list}.
    - Target format: {target_format}.
    - Output policy and location: "in_place" or {output_directory}.
    - Retention policy (kept or deleted originals).
    - Whether this was a dry-run or actual conversion.
    - Counts from the script/log:
      - total_candidates.
      - converted_count (or would_convert_count if dry-run).
      - skipped_count (including skipped_same_format).
      - error_count.
    - Approximate total input size processed (derived from total_input_bytes, converted to MB/GB).
    - The log file path {log_file_path} so the user can inspect or reuse the mapping.
    - Any notable warnings, such as safety limits reached or directories that could not be accessed.
    Then:
    - If actual conversion ran and results are acceptable:
      - Call "mark task completed" with a short message summarizing counts and pointing to {log_file_path}.
    - If the user chose to stop after dry-run without converting:
      - Clearly state that no files were changed, and still call "mark task completed" (dry-run only) unless they consider it incomplete.
    - If the user canceled mid-flow or changed their mind before conversion:
      - Call "mark task cancel" with the reason.
    - If the script failed in a way that prevented meaningful conversion (e.g., Pillow could not be installed, or critical directories were inaccessible):
      - Call "mark task error" with a short explanation and include {log_file_path} if any partial log exists.
