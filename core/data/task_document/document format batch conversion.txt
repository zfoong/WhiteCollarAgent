name: Document format batch conversion
description: Convert multiple documents between formats (e.g., DOCX, ODT, PDF, TXT) in one or more folders using CLI-based tools, aiming to preserve structure and style as much as the target format and converter allow. Use a minimal number of efficient actions and produce a simple log.

goal/outcome:
  - All selected source documents under {source_root_directories} are converted to the requested target format(s) according to user-defined rules.
  - File content, structure, and styling are preserved as much as reasonably possible for the chosen target format (recognizing that some conversions, such as to TXT, are inherently lossy).
  - Original files are kept or removed according to {original_file_policy} (e.g., keep, delete after successful conversion).
  - Target files are saved under {output_root_directory} or alongside originals, following the agreed naming convention (e.g., {original_basename}.{target_extension}).
  - No files outside the specified source roots are touched.
  - No target files are silently overwritten; name collisions are handled predictably (e.g., append a counter).
  - A single log file {log_file_path} exists in the workspace showing, for each file: source path, target path, source format, target format, status, and any error.
  - The user receives a brief summary with counts (converted/skipped/errored), formats used, and the log location.

inputs_params:
  - Required: {source_root_directories} – one or more root directory paths containing documents to convert.
  - Required: {source_formats} – list of input formats to include (e.g., ["docx", "odt", "pdf", "txt"]).
  - Required: {target_format} – the desired output format (e.g., "pdf", "docx", "txt", "odt").
  - Optional: {output_root_directory} – base directory for converted files; if omitted, output files are placed next to their sources.
  - Optional: {original_file_policy} – "keep" (default) or "delete_after_success".
  - Optional: {preserve_folder_structure} – whether to mirror the source folder structure under {output_root_directory} (true/false).
  - Optional: {overwrite_policy} – "skip_if_exists" (default) or "append_counter".
  - Optional: {dry_run} – if true, only list what would be converted and where, without creating files.
  - Optional: {max_files} – safety cap on number of files to process.

context:
  reasoning:
    - Keep the workflow simple and efficient: confirm what to convert, then perform a single scripted traversal that both discovers files and converts them.
    - Use "create and run python script" to:
      - Walk {source_root_directories}.
      - Filter files by {source_formats}.
      - Decide target paths and handle collisions.
      - Call a conversion tool (e.g., pandoc or similar) via subprocess for each file.
      - Log results as it goes.
    - Prefer one script (or at most two when using a dry run followed by a real run) instead of many small actions.
    - Do not use GUI mode; CLI is sufficient.
    - For lossy conversions (e.g., DOCX → TXT), maintain structural cues where possible (e.g., headings separated by blank lines), but do not overcomplicate; rely on the converter’s defaults.
    - Failures should be recorded per-file in the log and surfaced in the final summary, without stopping the entire batch unless absolutely necessary.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - For non-dry-run mode:
      - Every selected source file either has a corresponding target file created or is logged as skipped/error with a reason.
      - No unexpected overwrite occurred; any conflict was handled per {overwrite_policy}.
      - Original files were kept or removed according to {original_file_policy}.
    - For dry-run mode:
      - The log correctly lists all files that would be converted and their intended target paths, with no actual conversions performed.
    - The log file {log_file_path} exists in the workspace and includes, per row, at least:
      - source_path, target_path, source_format, target_format, status, error_message.
    - The user has received a short summary stating:
      - source roots, source/target formats,
      - total files scanned and matched,
      - numbers converted, skipped, and errored,
      - log file location.
  avoid:
    - Converting files outside {source_root_directories}.
    - Deleting or overwriting originals unless {original_file_policy} explicitly allows it.
    - Complex multi-step mapping or preview flows beyond an optional simple dry-run.
    - Using GUI mode or multiple redundant scans.
    - Assuming perfect fidelity for inherently lossy conversions; instead, aim for “best effort” and rely on well-known converters.

steps:
  name: Confirm conversion scope and rules
  description: Ensure all key parameters for the batch conversion (paths, formats, and policies) are clearly defined and confirmed by the user before any work.
  action_instruction: >
    Use the "send_message" action to restate and confirm the required inputs:
    - {source_root_directories}: the folder(s) to search for documents.
    - {source_formats}: which source formats to include (e.g., docx, odt, pdf, txt).
    - {target_format}: the single target format for this batch (or clearly define if multiple targets are requested).
    - {output_root_directory}: whether to place converted files under a specific directory or alongside originals.
    - {preserve_folder_structure}: whether to mirror the source directory structure under {output_root_directory}.
    - {original_file_policy}: keep originals or delete after successful conversion.
    - {overwrite_policy}: skip if the target exists or append a counter.
    - {dry_run}: whether to first preview what would be converted.
    - {max_files}: an upper bound on how many files to process, if the user wants a safety cap.
    Ask the user to confirm or correct any unclear items. If something critical is missing (for example, target format or how to treat originals),
    use the "send_message" action with a focused question. Once answers are received, send a brief "send_message" summarizing
    the final parameters in one place.
  validation_instruction: >
    Check that:
    - {source_root_directories} is non-empty.
    - {target_format} is clearly specified.
    - {source_formats} is non-empty and does not conflict with {target_format} expectations.
    - {original_file_policy} and {overwrite_policy} have sensible defaults if the user does not care.
    Only proceed once the user has clearly acknowledged the summarized parameters.

  name: Run batch conversion script (scan and convert)
  description: In a single efficient script, traverse the source folders, select files matching the requested formats, and perform conversions (or just log them if in dry-run mode), recording results to a log file.
  action_instruction: >
    Use the "create and run python script" action with code that:
    - Defines configuration variables based on the confirmed inputs:
      - source_roots = {source_root_directories}
      - source_formats = {source_formats} (normalized to lower-case extensions without leading dots for comparison)
      - target_format = {target_format}
      - output_root = {output_root_directory} or None (for in-place output)
      - preserve_structure = {preserve_folder_structure}
      - original_policy = {original_file_policy}
      - overwrite_policy = {overwrite_policy}
      - dry_run = {dry_run}
      - max_files = {max_files} or None
      - log_file_path = {log_file_path} (e.g., "document_conversion_log_{date_time}.csv" in the workspace)
    - Walk each source root using os.walk:
      - Skip any non-existent roots with a printed info message.
      - For each file, detect its extension (lower-case, without dot).
      - If the extension is in source_formats:
        - If max_files is set and already reached, stop collecting more files.
        - Decide the target directory:
          - If output_root is provided and preserve_structure is true, reconstruct the path relative to the source root under output_root.
          - If output_root is provided and preserve_structure is false, place all outputs directly under output_root.
          - If no output_root is provided, use the source file’s directory.
        - Build the base target file name: {original_basename}.{target_format}.
        - Apply overwrite_policy:
          - If "skip_if_exists" and the target file already exists, mark this file as "skipped_exists".
          - If "append_counter", append "_1", "_2", etc. until a free file name is found.
        - If dry_run is True:
          - Do not call any converter; just mark status as "would_convert" (or "skipped_exists" if applicable).
        - If dry_run is False:
          - Ensure the target folder exists (os.makedirs(target_dir, exist_ok=True)).
          - Call a document conversion tool via subprocess (e.g., pandoc), for example:
            - command like: ["pandoc", source_path, "-o", target_path]
            - capture return code and stderr.
          - If return code is 0, status = "converted".
          - If non-zero or an exception occurs, status = "error" and capture a short error message.
          - If original_policy is "delete_after_success" and status == "converted", remove the original file.
        - For each file considered (including skipped), write a CSV log line with:
          - source_path, target_path, source_format, target_format, status, error_message.
    - After processing all roots:
      - Print to stdout:
        - total_files_scanned,
        - total_files_matched,
        - count_converted (or would_convert),
        - count_skipped_exists,
        - count_errors,
        - log_file_path.
  validation_instruction: >
    Inspect the output of "create and run python script":
    - Confirm that the script completed without an unhandled exception.
    - Check that total_files_matched and count_converted (or would_convert) are reasonable given the user’s expectations.
    - Ensure that a log_file_path is printed and points to a location in the workspace.
    - If total_files_matched is 0, notify the user via "send_message" that no matching documents were found and ask whether to
      adjust formats/paths or stop the task.
    - If the error count is unexpectedly high, prepare to mention this clearly in the final summary.

  name: Overall validate conversion results
  description: Perform a simple final check against the definition_of_done using the script summary and the log file, without introducing extra scans.
  action_instruction: >
    Use the high-level summary from the script’s stdout along with a lightweight log inspection to validate:
    - If needed, use "shell view" or a small "create and run python script" to:
      - Open {log_file_path}.
      - Count rows by status (converted, would_convert, skipped_exists, error).
    - Verify:
      - The total number of logged entries matches total_files_matched reported by the script.
      - There is at least one successful conversion if the user expected output.
      - Errors, if any, are recorded but do not indicate a complete failure of the batch.
    - For dry_run tasks, confirm that statuses are "would_convert" or "skipped_exists" only (no actual "converted" entries).
    If something looks clearly inconsistent (e.g., log is missing or empty despite non-zero matches), prepare to explain that to the user and, if necessary, rerun the conversion script once with corrected parameters. Otherwise, proceed to reporting.
  # No extra validation_instruction beyond these simple checks.

  name: Close task and report to user
  description: Summarize what was (or would be) converted, provide the log file location, and mark the task status appropriately.
  action_instruction: >
    Use "send_message" to provide a concise final summary:
    - Source roots processed: {source_root_directories}.
    - Source formats and target format: {source_formats} → {target_format}.
    - Output location policy: {output_root_directory} (or "next to originals") and whether folder structure was preserved.
    - Original file policy: {original_file_policy}.
    - Overwrite policy: {overwrite_policy}.
    - Whether it was a dry-run or actual conversion.
    - Counts from the script:
      - total_files_scanned,
      - total_files_matched,
      - converted (or would_convert),
      - skipped_exists,
      - error count.
    - The log file path: {log_file_path}.
    For a dry-run where the user is satisfied without performing real conversions, clearly state that no files were changed.
    If conversions were actually performed and the results are acceptable:
      - Call "mark task completed" with a short message summarizing the key counts and the log file path.
    If the user decides not to proceed after seeing a dry-run:
      - Call "mark task cancel" with a brief reason (e.g., user chose not to convert after preview).
    If significant errors prevented meaningful conversion (for example, converter tool unavailable for all files):
      - Call "mark task error" with a short explanation and point the user to {log_file_path} for details.
