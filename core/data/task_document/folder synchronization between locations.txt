name: Folder synchronization between locations
description: Keep two or more directories in sync by copying new and changed files according to a simple, user-defined sync policy. Use efficient CLI-based scripts, minimal passes, and straightforward conflict handling and logging.

goal/outcome:
  - The specified directories ({source_dirs} and {target_dirs}) are synchronized according to the chosen sync mode and conflict policy.
  - New files and changed files are copied in the correct direction(s); unchanged files are left untouched.
  - Simple conflicts (e.g., same file changed in both places) are handled consistently according to the user’s chosen rule.
  - No files outside the specified directories are modified.
  - A single sync log file in the workspace (e.g., {log_file_path}) records per-file actions: copied, skipped, conflict, or error.
  - The user receives a concise summary describing the sync scope, policy used, number of files copied/skipped/conflicted, and the log file location.

inputs_params:
  - Required: List of directories to sync:
    - Typically one or more {source_dirs} and one {target_dir}, or two peers for two-way sync.
  - Required: Sync mode:
    - "one-way": sync from {source_dir} → {target_dir} only.
    - "two-way": bidirectional sync between {dir_a} and {dir_b}.
  - Required: Conflict policy for changed files that differ on both sides:
    - "newer-wins": keep the file with the newer modification time.
    - "source-wins": source overwrites target (for one-way).
    - "target-wins": target overwrites source (for one-way).
    - "skip": do not overwrite; record as conflict.
  - Optional: Scope options:
    - Recursive: whether to include subdirectories (true/false, default true).
    - Include patterns (e.g., by extension: ".txt", ".jpg").
    - Exclude patterns or paths to ignore (e.g., ".git", ".cache").
  - Optional: Deletion behavior:
    - Whether to mirror deletions (remove files that exist only on one side) or only copy/add.
  - Optional: Dry-run flag:
    - If true, compute and log planned operations without changing any files.
  - Optional: Safety caps:
    - Maximum number of files to modify, or maximum total bytes to transfer before stopping or asking again.

context:
  reasoning:
    - Keep the workflow short and efficient: confirm sync direction and rules, scan and compare in a single script, then apply operations and log results.
    - Prefer a single "create and run python script" call per sync (or per pass) that:
      - Validates directories.
      - Walks directories (using os.walk) according to recursion and filters.
      - Compares file timestamps and sizes (or hashes if explicitly requested, but default to timestamps + size).
      - Decides actions per file based on sync mode and conflict policy.
      - Executes copy/move operations or simulates them in dry-run.
      - Writes a log file and prints a short summary to stdout.
    - Avoid GUI; CLI is sufficient.
    - Use a dry-run only when requested or when the user seems unsure about the impact.
    - Keep conflict handling simple and consistent: apply the chosen rule deterministically and record it in the log.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The specified directories have been processed according to the agreed sync mode and conflict policy.
    - Files intended to be synchronized are copied or updated; skipped/conflicted items are logged with a clear reason.
    - No files were modified outside the specified directories.
    - No unexpected overwrites occurred contrary to the chosen conflict policy.
    - A log file {log_file_path} exists in the workspace listing per-file action/status and is referenced in the final summary.
    - The user has received a brief report describing:
      - Directories involved.
      - Sync mode and conflict policy used.
      - Counts of copied/updated/skipped/conflicted/errored files.
      - Any notable limitations (e.g., safety cap reached).

  avoid:
    - Overcomplicated strategies (e.g., multi-phase hashing or snapshot systems) unless explicitly requested.
    - Using GUI mode or multiple redundant directory scans.
    - Attempting to sync entire system drives without user-specified roots.
    - Silent overwrites that contradict the conflict policy.
    - Implementing complex versioning; a simple log plus conflict rule is enough for this task.

steps:
  name: Confirm sync scope and rules
  description: Clarify which directories to sync, the direction of sync, and conflict/deletion behavior. Keep this confirmation concise and explicit.
  action_instruction: >
    Use the "send_message" action to restate the planned sync in simple terms and ask the user to confirm or correct:
    - Directories involved, e.g., {source_dir} and {target_dir}, or {dir_a} and {dir_b}.
    - Sync mode: "one-way" ({source_dir} → {target_dir}) or "two-way" ({dir_a} ↔ {dir_b}).
    - Conflict policy for files changed on both sides: "newer-wins", "source-wins", "target-wins", or "skip".
    - Whether to include subdirectories (recursive true/false).
    - Include patterns/extensions (if any) and exclude patterns/paths (if any).
    - Deletion behavior:
      - "copy-only" (do not delete anything), or
      - "mirror" (delete files that exist only on one side according to the sync mode).
    - Whether a dry-run is desired before applying real changes.
    - Any safety caps such as maximum files or total size to modify.
    If any of these are unclear or missing (e.g., user did not specify conflict policy), use "send_message" with a focused
    question (e.g., "When the same file is changed in both places, should the newer one win or should we skip?").
    After receiving the user’s replies, send a short "send_message" summarizing the final parameters
    (e.g., "Sync {source_dir} → {target_dir}, recursive, newer-wins, copy-only, dry_run={dry_run_flag}").
  validation_instruction: >
    Confirm that:
    - There are at least two directory paths defined and they are not obviously invalid strings.
    - Sync mode is explicitly one of the supported modes.
    - A conflict policy is chosen; if not, default to "newer-wins" only after explicitly telling the user and getting agreement.
    - Deletion behavior is clearly understood ("copy-only" vs "mirror").
    - Dry-run vs actual sync is decided.
    Proceed only when the parameters are clearly confirmed in the conversation.

  name: Plan and (optionally) dry-run sync
  description: Traverse the directories, compare files, and determine what would be copied, updated, deleted, or skipped under the chosen rules. Perform a dry-run if requested.
  action_instruction: >
    Use "create and run python script" with a single script that:
    - Accepts as input (hardcoded or via simple configuration inside the script):
      - dir_a and dir_b (or {source_dir} and {target_dir}).
      - sync_mode ("one-way" or "two-way").
      - conflict_policy.
      - recursive flag.
      - include and exclude patterns.
      - deletion_behavior ("copy-only" or "mirror").
      - dry_run (True/False).
      - safety caps (max_files, max_bytes) if any.
      - a log file path in the workspace, such as "sync_log_{timestamp}.csv".
    - Defines a helper to list files in each directory (using os.walk for recursive, or os.listdir for non-recursive),
      returning a mapping from relative_path → (absolute_path, size, mtime).
    - Builds file maps for the two sides:
      - For one-way sync, treat {source_dir} as source and {target_dir} as target.
      - For two-way sync, treat dir_a and dir_b as peers.
      - Apply include/exclude patterns to filter which relative paths are considered.
    - For each relative_path across both maps:
      - Determine presence:
        - present only on one side,
        - present on both with same size/mtime (unchanged),
        - present on both with different size/mtime (potential conflict/updated).
      - Decide an action based on sync_mode, conflict_policy, and deletion_behavior:
        - copy source → target (new or updated),
        - copy target → source (in two-way mode),
        - delete from one side if "mirror" is enabled and the file exists only on that side,
        - skip if unchanged or if conflict_policy=="skip" for that case.
      - Track planned operations (copy, delete, skip) in memory.
      - Respect safety caps: if the number of planned modifications or total bytes exceeds limits, stop planning more and record this in summary.
    - If dry_run is True:
      - Do not perform any filesystem changes.
      - For each planned operation, log an action like "would_copy_source_to_target", "would_delete_in_target", etc.
    - If dry_run is False:
      - Execute each planned operation with shutil.copy2 (to preserve timestamps) for copies and os.remove for deletions.
      - On errors (permissions, path length), record status="error" and continue.
    - For each relevant file, write a log line containing:
      - side_a_path (or empty if not present),
      - side_b_path (or empty if not present),
      - action ("copy_a_to_b", "copy_b_to_a", "delete_in_a", "delete_in_b", "skip", "error", or "would_*" variants),
      - size_bytes,
      - error_message (if any).
    - At the end, print to stdout:
      - Sync mode and conflict policy used.
      - Counts of each action (copies, deletes, skips, errors).
      - Approximate total bytes copied/deleted.
      - Whether safety caps were hit.
      - Log file path {log_file_path}.
  validation_instruction: >
    Inspect the output of "create and run python script":
    - Ensure the script completed without unhandled exceptions.
    - Confirm that it reports a log file path and non-empty summary lines.
    - Note counts of planned or performed actions and any mention of safety caps.
    For dry-run:
      - Verify that actions are "would_*" variants and that no indications of actual file modification appear in stdout.
    For actual run:
      - Verify that at least some actions ("copy_*", "delete_*") are reported if the user expected changes.
    If the script failed globally or produced obviously inconsistent counts, explain this via "send_message" and either
    correct the script and rerun, or prepare to "mark task error" if it cannot be fixed simply.

  name: (Optional) Execute real sync after dry-run
  description: If the user requested a dry-run first, optionally rerun the sync script with dry_run disabled using the same parameters.
  action_instruction: >
    If the initial run was a dry-run:
      - Use "send_message" to:
        - Inform the user that the dry-run has completed.
        - Provide a short summary: number of files that would be copied/deleted/skipped, approximate total bytes affected,
          and the log file path.
        - Ask whether to proceed with the actual sync using the same parameters (dry_run=False).
      - If the user agrees:
        - Call "create and run python script" again with dry_run set to False and the same configuration
          (directories, sync_mode, conflict_policy, deletion_behavior, patterns, safety caps).
      - If the user declines:
        - Clarify that no files were changed and proceed to the final reporting step.
  validation_instruction: >
    For the second (real) run:
    - Validate as in the previous step:
      - Successful script completion.
      - Counts of actions (copies/deletes/skips/errors).
      - Log file path present.
    If the user chooses not to proceed beyond dry-run, no further file validation is required.

  name: Overall validate synchronization
  description: Perform a minimal but sufficient validation that the sync behaved as expected, using the log and script summary.
  action_instruction: >
    Use the script’s stdout summary and the log file {log_file_path} to do a quick consistency check:
    - Use "shell view" or a small "create and run python script" to:
      - Count total log entries.
      - Count each category of action (copies, deletes, skips, errors or their "would_*" analogs).
    - Check that:
      - The counts in the log match what the script reported in stdout.
      - If the user expected real sync, there is at least a non-zero number of "copy_*" or "delete_*" actions.
      - Errors (if any) are limited and recorded; they can be mentioned in the final summary.
    No extra directory scan is necessary unless the user explicitly asks for deeper verification or the counts look clearly wrong.
  # No separate validation_instruction needed beyond these checks.

  name: Close task and report to user
  description: Summarize the sync operation (or dry-run), share the log location, and mark task status.
  action_instruction: >
    Use "send_message" to give a concise final summary:
    - Directories synchronized: list {dir_a}, {dir_b}, and any additional locations.
    - Sync mode and conflict policy used.
    - Deletion behavior ("copy-only" or "mirror").
    - Whether this was dry-run only or an actual sync.
    - Counts of files copied/updated, deleted (if any), skipped, and errored.
    - Approximate total bytes copied/deleted.
    - The path to the sync log file {log_file_path} in the workspace.
    If the sync (or dry-run) completed as expected:
      - For actual sync, call "mark task completed" with a short message including key counts and the log path.
      - For dry-run only (per user’s choice), also call "mark task completed" but clearly state that no files were changed.
    If the user decided to stop after seeing parameters or dry-run output:
      - Call "mark task cancel" with a brief reason.
    If repeated script failures or access issues prevented meaningful synchronization:
      - Call "mark task error" with a clear explanation and reference to the log for partial results.
