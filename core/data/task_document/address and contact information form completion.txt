name: Address and contact information form completion
description: Fill contact, address, and profile forms using data from a structured source (e.g., JSON, CSV, document, or API response). Prepare the data via simple CLI scripts, then switch to GUI only for the actual form filling and submission.

goal/outcome:
  - All specified forms (contact, address, profile) are filled using data from a single structured source {source_location}.
  - Core contact fields are consistently populated where available:
    - name, email, phone, company, job title.
  - Core address fields are consistently populated where available:
    - street, city, state/region, postal code, country.
  - Any additional profile fields (e.g., website, bio, social links) are filled when present in the source.
  - Required form fields are not left empty; if source data is missing, the user is asked once or a clear default is used (e.g., left blank with explanation).
  - No obviously wrong field placements (e.g., email in phone field, city in postal code).
  - A short summary message is sent to the user listing:
    - which forms were filled,
    - which source record was used,
    - any required fields that had to be left blank or manually filled.
  - Optional: a small mapping log file in the workspace (e.g., {mapping_log_path}) lists key form fields and values used.

inputs_params:
  - Required: Structured data source specification:
    - {source_type}: e.g., "json_file", "csv_file", "docx_file", "pdf_file", "api".
    - {source_location}: e.g., file path, URL, or API endpoint.
  - Required: Target form context:
    - {form_kind}: e.g., "web form", "desktop app form", "intranet profile form".
    - {form_identifier}: e.g., {form_url} for web, or {application_name}/{window_title} for desktop.
  - Optional: Record selection:
    - {record_id} or {record_index} when the structured source contains multiple contacts/profiles.
  - Optional: Field mapping overrides:
    - Custom mapping from source keys to form field labels/IDs, e.g.,
      - "first_name" -> "First Name",
      - "phone_mobile" -> "Mobile".
  - Optional: Required field list and priority:
    - e.g., ["email", "phone", "street", "city", "postal_code"].
  - Optional: Fields to skip:
    - e.g., sensitive fields the user does not want filled (tax ID, secondary phone).
  - Optional: Dry-run flag:
    - If true, only prepare mapping and show preview; do not actually submit or change forms.

context:
  reasoning:
    - Keep the flow simple: confirm data source and target form, load and normalize the data once using a short Python script, derive a clear field mapping, then use GUI only to apply this mapping to the form.
    - Use "create and run python script" to read/parse the structured data from {source_location} and standardize it into a simple dictionary with canonical keys (name, email, phone, street, city, postal_code, country, etc.).
    - If multiple records exist, allow the user to pick the correct one (by {record_id} or a brief preview) before filling any forms.
    - Use a compact mapping strategy:
      - start from default canonical mappings (e.g., "email" -> "Email", "street" -> "Street"),
      - then apply any user-provided overrides.
    - Avoid complex heuristics; only guess obvious mappings (e.g., case-insensitive label matches or simple underscores/space normalization).
    - Switch to GUI mode only when ready to fill a specific form, and perform the minimal sequence of clicks/keystrokes needed.
    - If a field is required but missing in the source, ask the user once via "send_message" or leave it empty with a note in the summary.
    - Optional: write a small log file via "create text file" capturing the final field->value mapping used for each form.

  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The selected source record is clearly identified (e.g., by {record_id} or key attributes).
    - For each target form:
      - All required contact and address fields that exist in the source are filled.
      - No obviously mismatched field content (e.g., numeric-only postal code appearing in "country" field).
      - If dry-run=false, the form has been either:
        - successfully submitted, or
        - saved as a draft, depending on user instruction.
    - If dry-run=true, no form fields were modified; only mapping/preview was produced.
    - A concise summary was sent to the user describing:
      - which form(s) were handled,
      - which record was used,
      - which fields were missing or left for manual completion.
    - If a mapping log file is requested, it exists at {mapping_log_path} in the workspace and matches what was filled.

  avoid:
    - Guessing unclear fields when the label or expected format is ambiguous; instead, ask once or leave them for manual fill.
    - Overwriting existing profile data without the user’s consent when editing an existing profile.
    - Running unnecessary extra passes over the data source; load and normalize it once.
    - Using GUI mode before the data and mapping are prepared.
    - Attempting complex ML-based field inference; stick to straightforward key/label matches and user-provided mappings.

steps:
  name: Confirm data source and target form
  description: Make sure the structured source, target form, and record to use are clearly defined and agreed with the user.
  action_instruction: >
    Use "send_message" to restate what is needed:
    - {source_type} and {source_location} (e.g., JSON file at {source_file_path}, or API at {api_url}).
    - Whether the source contains one record or multiple; if multiple, how to identify the correct record (e.g., by email or {record_id}).
    - The target form context:
      - {form_kind} and {form_identifier} (e.g., "web form at {form_url}" or "profile window in {application_name}").
    - Whether the agent is allowed to submit the form automatically or should stop after filling for user review.
    - Optional field mapping overrides (if the user wants specific keys to map to specific fields).
    Ask the user to confirm or provide missing details. If a critical part is unclear (e.g., which record to use or whether to submit),
    use "send_message" with a focused prompt (e.g., "Which record (by email or ID) should I use for the form at {form_url}?").
    Once clarified, send a brief "send_message" listing:
    - {source_location}, chosen {record_id} or description, and {form_identifier}.

  validation_instruction: >
    Confirm before proceeding:
    - {source_location} is specified.
    - There is a clear record selection strategy (single record or chosen {record_id}/{record_index}).
    - {form_identifier} is given and the user has indicated whether submission is allowed.
    If any of these are missing, call "send_message" again. Only proceed when these are concrete.

  name: Load and normalize structured data
  description: Use a single Python script to load the structured source and produce a normalized contact/profile dictionary for the chosen record.
  action_instruction: >
    Use "create and run python script" with code that:
    - Reads the structured source based on {source_type} and {source_location}:
      - json_file: use json.load on {source_file_path}.
      - csv_file: use csv.DictReader and pick the row by {record_id} or {record_index}.
      - docx_file: use "read word file" beforehand or within Python using python-docx, then parse simple "key: value" lines.
      - pdf_file: optionally use "read pdf file" first and parse similar "key: value" patterns if feasible.
      - api: use "send HTTP requests" to GET {api_url} and parse a JSON-like response.
    - Select the appropriate record (row/object) using {record_id} or other unique field agreed with the user.
    - Construct a normalized dictionary, e.g.:
      - full_name, first_name, last_name,
      - email, phone, mobile_phone,
      - company, job_title,
      - street, city, state, postal_code, country,
      - website, bio, other optional keys.
    - Handle missing keys by simply not adding them or setting None.
    - Print to stdout a compact summary (e.g., full_name, email, city, country) and indicate success or any missing critical fields.
    Optionally, write the normalized record to a small JSON or text file {normalized_data_path} using Python file I/O and/or "create text file".
  validation_instruction: >
    Check the script's action output:
    - Status shows success, not an unhandled exception.
    - The summary in stdout shows the expected record (e.g., correct email or name).
    - At least core fields (e.g., name + one contact method such as email or phone) are present.
    If loading or parsing fails, briefly explain via "send_message" and either:
    - Ask the user for a different {source_location}/{source_type}, or
    - "mark task error" if the source cannot be parsed in this session.

  name: Build simple field mapping for the target form
  description: Decide how normalized data keys map to the target form’s labels/fields, combining defaults with any user overrides.
  action_instruction: >
    In reasoning:
    - Start from a small default mapping from normalized keys to standard form labels, e.g.:
      - full_name -> "Full Name" or "Name"
      - first_name -> "First Name"
      - last_name -> "Last Name"
      - email -> "Email" or "Email Address"
      - phone -> "Phone" or "Phone Number"
      - street -> "Street" or "Address Line 1"
      - city -> "City"
      - state -> "State" or "Region"
      - postal_code -> "ZIP" or "Postal Code"
      - country -> "Country"
      - website -> "Website" or "URL"
    - Apply any user-provided overrides so that, for example, "email" goes to "Work Email" instead of "Email".
    - If the target form is known (e.g., {form_url}), you may assume common label variants, but do not overcomplicate;
      stick to obvious string matches (case-insensitive, underscores vs spaces).
    - Prepare a concise internal list of (normalized_key, form_label, value) triplets containing only keys that actually have values.
    Optional:
    - Use "create text file" to write this mapping to {mapping_log_path} as a simple table (for later reference).
  validation_instruction: >
    Ensure:
    - Each normalized key with a non-empty value maps to at most one form label.
    - Required fields (if the user specified them) have a mapping when data exists.
    - If a required field has no data in the source, plan to ask the user once during filling or mention it in the final summary.
    No extra actions are needed if mapping is straightforward.

  name: Fill the target form using GUI
  description: Switch to GUI mode and use the prepared mapping to populate the form fields in the target application or web page.
  action_instruction: >
    - Call "switch to GUI mode" to enable GUI operations.
    - In GUI mode (handled by the underlying system):
      - Open or focus the target form:
        - For web: navigate to {form_url} in the default browser.
        - For desktop/intranet: bring the {application_name}/{window_title} containing the form to the foreground.
      - For each (normalized_key, form_label, value) in the mapping:
        - Locate the field by its visible label or placeholder text (e.g., "Email", "Street", "Postal Code").
        - Click into the field or focus it.
        - Clear any existing content if appropriate (especially for new entries; be careful for existing profiles).
        - Type the corresponding value.
      - If any required field has no value from the source:
        - Option 1: ask the user via "send_message" once (e.g., "What is the postal code for {full_name}?") and then fill it.
        - Option 2 (if user prefers no prompts): leave the field blank and plan to mention it in the summary.
      - If the user authorized submission and this is not a dry-run:
        - Click the submit/save button.
      - If the user did not authorize automatic submission:
        - Leave the form filled but not submitted, so they can review.
    - Optionally, use "screenshot" to save a screenshot at {screenshot_path} if needed for later confirmation.
  validation_instruction: >
    After filling:
    - Visually (via GUI event feedback) confirm that fields appear filled with the expected values.
    - If a confirmation or success message appears after submission (e.g., "Profile updated"), treat this as success.
    - If the page displays validation errors (missing required fields or format issues), either:
      - Correct them using available data or with a single clarifying "send_message" to the user, or
      - Leave them and mention them in the final summary.
    No extra CLI validation is required beyond obvious GUI confirmation.

  name: Overall validate form completion
  description: Check that the actual filled form matches the normalized data and that the main conditions in the definition_of_done are met.
  action_instruction: >
    - In reasoning, compare:
      - The normalized data (from the script) vs. what was filled (from your mapping and GUI confirmation).
    - Confirm:
      - All required fields that had data were filled.
      - No obviously mismatched values were placed into fields with a different expected type.
      - If submission was allowed, a success/confirmation indication was observed.
    - If major issues remained (e.g., form could not be submitted or critical fields refused values), plan to describe this clearly in the final summary.
    No extra tools are necessary unless you want to briefly inspect {mapping_log_path} via "shell view" (optional).

  name: Close task and report to user
  description: Provide a concise summary of what was done, note any missing data or manual steps needed, and mark task status.
  action_instruction: >
    Use "send_message" to summarize:
    - Which source was used ({source_location} and, if applicable, {record_id} or key attribute).
    - Which form or forms were filled ({form_identifier}).
    - Whether the form(s) were submitted or left for user review.
    - Any required fields that were missing from the source and how they were handled (asked, left blank, or errored).
    - The existence and path of {normalized_data_path} and {mapping_log_path}, if they were created.
    - Any screenshots {screenshot_path}, if captured.
    If the forms were filled as intended (and submitted or left for review per user instructions):
    - Call "mark task completed" with a short success message referencing the form and source.
    If the user canceled or asked to stop after mapping/dry-run:
    - Call "mark task cancel" with the reason.
    If loading the source or filling the form failed in a way that prevented meaningful completion:
    - Call "mark task error" with a brief explanation and, if available, pointers to partial artifacts (e.g., normalized data or logs).
