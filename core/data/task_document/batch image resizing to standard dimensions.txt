name: Batch image resizing to standard dimensions
description: Resize large sets of images in one or more folders to specified dimensions (or max edge) for web or document use, using a single efficient script and simple logging.

goal/outcome:
  - All target images under {input_directories} are resized according to the user-defined size rule (fixed width/height or max edge) and saved as requested (in-place or into {output_directory}).
  - Image formats are preserved by default (e.g., .jpg stays .jpg, .png stays .png) unless the user explicitly requests a single target format.
  - Aspect ratio handling (preserve with fit, preserve with crop, or ignore and stretch) matches the user’s choice.
  - Non-image files and explicitly excluded paths are not modified.
  - A single log file is created in the workspace mapping original image paths to new image paths, including original and new sizes and per-file status.
  - The user receives a concise summary describing how many images were processed, how many were resized or skipped, and where the log file is stored.

inputs_params:
  - Required: One or more root directories containing images to process (e.g., {input_directories}).
  - Required: Target size strategy (one of):
    - Fixed dimensions: {target_width} x {target_height} pixels.
    - Max dimension: longest side = {max_edge_px} pixels (other side scaled to preserve aspect ratio).
  - Required: Aspect ratio mode:
    - preserve_scale: keep aspect ratio, fit inside target box (may leave borders if combined with exact canvas).
    - preserve_crop: resize and center-crop to exact {target_width} x {target_height}.
    - stretch: ignore aspect ratio and scale directly to {target_width} x {target_height}.
  - Optional: Output mode:
    - in_place: overwrite originals with resized versions.
    - to_folder: write resized images to {output_directory}, preserving subfolder structure under that root.
  - Optional: Target format (e.g., "jpg", "png", "webp"); default is "preserve_original_format".
  - Optional: Quality settings for lossy formats (e.g., JPEG quality {jpeg_quality} between 1–95; default reasonable value like 80–90).
  - Optional: Include patterns / extensions (e.g., [".jpg", ".jpeg", ".png", ".webp"]); default is common image extensions.
  - Optional: Exclude patterns / paths (e.g., {exclude_directories}, {exclude_patterns}).
  - Optional: Minimum size filter (e.g., only resize if width > {min_width} or height > {min_height}).
  - Optional: Dry-run flag (True/False) to see which files would be resized without changing anything.
  - Optional: Safety cap for maximum number of images to process (e.g., {max_files}).

context:
  reasoning:
    - Keep the workflow simple: confirm parameters, run a single Python script to walk directories and resize images, log results, and summarize.
    - Use "create and run python script" in CLI mode to:
      - Install and import Pillow (PIL) inside the script if needed.
      - Traverse {input_directories} with os.walk, filter files by extension and exclude rules, and optionally apply minimum size checks.
      - For each image:
        - Open it with Pillow.
        - Compute the new dimensions based on the selected size strategy and aspect ratio mode.
        - If dry_run is True, do not save; only record what would change.
        - If dry_run is False, resize and save the image either:
          - Overwriting the original (in_place), or
          - To a mirrored path under {output_directory} (to_folder), creating directories as needed.
        - Preserve or convert format according to user preference, and apply a quality parameter for lossy formats.
        - Record original size, new size (or “unchanged”), and status in the log.
      - Write a single CSV or delimited text log file (e.g., {resize_log_path}) in the workspace.
      - Print a simple summary to stdout: total images seen, resized, skipped, errors, and the log path.
    - Use dry-run only when requested; otherwise, run directly to resizing to avoid extra passes.
    - No GUI is needed; CLI and Python are sufficient for this task.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - Only files in {input_directories} that match the include filters (and not excluded) are considered.
    - For non-dry-run:
      - Every eligible image is either resized according to the rules or skipped for a clear reason (e.g., already smaller than threshold, error opening file).
    - No non-image files are modified.
    - A log file exists at {resize_log_path} listing original path, output path, original size, new size, and status.
    - The final message to the user includes:
      - Directories processed.
      - Size strategy and aspect ratio mode.
      - Output mode and target format.
      - Counts of resized, skipped, and error images.
      - Path to the log file.
  avoid:
    - Using GUI mode or multiple complex workflows; one or two scripts are enough.
    - Changing image formats or quality without the user’s consent.
    - Resizing images that are already equal to or smaller than the target size when the user only wants to downscale.
    - Overwriting files unintentionally when output mode is to_folder (use mirrored structure or simple suffix if name collision happens).
    - Running multiple redundant scans when a single traversal with immediate processing is sufficient.

steps:
  name: Confirm image resize scope and settings
  description: Confirm which folders, size rules, aspect ratio mode, and output behavior to use before processing.
  action_instruction: >
    Use the "send_message" action to restate the planned configuration and request confirmation:
    - List {input_directories} that will be scanned.
    - Ask the user to choose the target size strategy:
      - Fixed size {target_width} x {target_height}, or
      - Max edge {max_edge_px} (preserve aspect).
    - Ask for the aspect ratio mode: "preserve_scale", "preserve_crop", or "stretch".
    - Ask for output mode: "in_place" (overwrite originals) or "to_folder" with {output_directory}.
    - Ask whether to preserve original formats or convert everything to a specific {target_format}.
    - Ask about JPEG quality (if applicable, default to a reasonable value if the user does not care).
    - Ask which extensions to include (default to common image types) and any directories or patterns to exclude.
    - Ask whether images smaller than the target should be resized or left unchanged.
    - Ask whether they want a dry-run first (log only, no changes).
    - Ask if they want a maximum number of images to process (e.g., stop after {max_files}).
    If anything essential is unclear (e.g., size strategy or output mode), use "send_message" with a focused question.
    Once clarified, send a short "send_message" summarizing the final agreed parameters so they are recorded.
  validation_instruction: >
    Before proceeding, ensure:
    - At least one {input_directory} is specified.
    - A valid size strategy is chosen (either fixed {target_width} x {target_height} or max edge {max_edge_px}).
    - An aspect ratio mode is chosen.
    - An output mode is chosen, and {output_directory} is set if needed.
    - Dry-run vs actual resize is decided.
    If any of these are missing, call "send_message" again. Proceed only once the user has explicitly confirmed.

  name: Resize images (or dry-run) with a single script
  description: Traverse the directories, identify image files, and either compute or perform the resize operations in one pass, logging all actions.
  action_instruction: >
    Use "create and run python script" with a single script that:
    - Installs Pillow (PIL) if it is not available, using pip inside the script.
    - Accepts parameters (embedded in the script) representing:
      - {input_directories},
      - size strategy ({target_width}, {target_height} or {max_edge_px}),
      - aspect_ratio_mode,
      - output_mode (in_place / to_folder),
      - {output_directory} (if used),
      - target_format (or None to preserve),
      - jpeg_quality,
      - include_extensions,
      - exclude_paths/patterns,
      - min_size filters (if any),
      - dry_run flag,
      - safety caps ({max_files}).
    - For each directory in {input_directories}:
      - Verify it exists and is a directory; if not, print a note to stdout and continue to the next.
    - Walk each valid directory with os.walk:
      - Skip excluded folders based on simple string matching if requested.
      - For each file:
        - Check its extension against include_extensions and exclude patterns; skip if not eligible.
        - Open the image with Pillow in a try/except block; on failure, record an "error" status in memory and continue.
        - Optionally apply minimum size filters using image.size.
        - Based on size strategy and aspect_ratio_mode:
          - Compute new dimensions and, if needed, cropping or stretching behavior.
        - If dry_run is True:
          - Do not save; just record what would be done (original size, intended new size, action="would_resize").
        - If dry_run is False:
          - Compute the output path:
            - For in_place: same path.
            - For to_folder: base it under {output_directory}, preserving relative structure from the root and creating directories as needed.
            - On collision (file already exists at output path), append a small suffix (e.g., "_1") to avoid overwriting.
          - Resize and save the image using Pillow, preserving or converting format as configured and applying jpeg_quality where relevant.
          - Record status "resized" for success, or "error" with message for failures.
        - Track processed count and stop early if {max_files} is reached, if provided.
    - After processing:
      - Write a log file {resize_log_path} in the workspace (e.g., CSV with fields:
        original_path, output_path, original_width, original_height, new_width, new_height, status, error_message).
      - Print a summary to stdout:
        - Total images seen.
        - Total successfully resized (or would_resize in dry-run).
        - Total skipped (filtered or too small).
        - Total errors.
        - Path to {resize_log_path}.
  validation_instruction: >
    Check the "create and run python script" output:
    - The status should indicate success (no unhandled exceptions).
    - The stdout summary should show counts for processed/resized/skipped/errors and provide {resize_log_path}.
    - If zero images were processed, send a short "send_message" explaining that no files matched the filters and ask the user
      whether they want to adjust parameters or stop.
    - For dry-run, ensure statuses like "would_resize" appear in the log (no actual changes expected).
    If the script fails globally (e.g., library installation issue or directory access error), briefly explain this to the user
    via "send_message" and decide whether to retry with a minor fix or treat it as a task error.

  name: (Optional) Run actual resize after dry-run
  description: If a dry-run was performed, optionally rerun the script with the same parameters to do the real resizing.
  action_instruction: >
    If dry_run was True and the script completed:
      - Use "send_message" to:
        - Inform the user the dry-run is complete.
        - Include key numbers (how many images would be resized and approximate coverage) and the {resize_log_path}.
        - Ask explicitly if they want to proceed with actual resizing using the same parameters.
      - If the user confirms:
        - Call "create and run python script" again with dry_run set to False and the same configuration.
        - The second run will repeat the traversal and actually save resized images.
      - If the user declines:
        - Clarify that no images were modified and proceed to final reporting.
  validation_instruction: >
    For the second run (if executed), validate as in the previous step:
    - Successful script status, non-zero resized count if expected, and a valid {resize_log_path}.
    - If the user declines to proceed after dry-run, no additional validation is needed beyond confirming that it remained a preview.

  name: Overall validate image resize batch
  description: Use the script summary and log file to ensure the operation matches the agreed definition_of_done with minimal extra checks.
  action_instruction: >
    Using either "shell view" or a small "create and run python script":
    - Open {resize_log_path}.
    - Count how many entries have status "resized" (or "would_resize" in dry-run), "skipped", and "error".
    - Confirm that the total count in the log matches the number reported in the script summary.
    - Confirm that some images were effectively resized if the user expected changes (unless it was dry-run by design).
    No full second scan of directories is needed if counts are consistent and there are no unexpected errors.

  name: Close task and report to user
  description: Provide a concise summary of the batch resize operation (or dry-run), expose the log path, and mark the task status.
  action_instruction: >
    Use "send_message" to summarize:
    - Directories processed ({input_directories}).
    - Size strategy (e.g., {target_width} x {target_height} or max edge {max_edge_px}).
    - Aspect ratio mode and output mode (in_place vs to_folder with {output_directory}).
    - Whether this was a dry-run or actual resize.
    - Counts of images resized (or would_resize), skipped, and errors.
    - Path to the log file {resize_log_path}.
    - For move-to-folder behavior, remind the user where resized outputs are stored.
    If the resize run completed as expected:
      - Call "mark task completed" with a brief success summary and the log path.
    If the user canceled after dry-run or changed their mind:
      - Call "mark task cancel" with a short reason (e.g., "user chose not to proceed after preview").
    If the task could not be completed due to persistent errors (e.g., directory access issues or repeated script failures):
      - Call "mark task error" with a concise description of what failed and where the partial log is located.
