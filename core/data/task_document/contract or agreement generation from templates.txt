name: Contract or agreement generation from templates
description: Fill one or more contract/agreements templates with specific party and project data to produce ready-to-review contract files (e.g., .docx and/or .pdf), using a simple placeholder-replacement workflow.

goal/outcome:
  - A completed contract or agreement file generated from a template at {template_path} and saved as {output_contract_path}.
  - All required placeholders in the template (e.g., {PARTY_A_NAME}, {PARTY_B_NAME}, {PROJECT_NAME}, {EFFECTIVE_DATE}) are replaced with the provided data.
  - No unresolved placeholders (e.g., brace-style tokens like {SOMETHING}) remain in the final output, unless explicitly intended by the user.
  - File format and naming follow the user’s preferences (e.g., {contract_type}_{party_A_name}_{date}.docx and optionally .pdf).
  - A short log or note exists summarizing which template was used, which placeholders were filled, and where the output file(s) are stored.
  - The user receives a concise summary message and can open/use the generated contract immediately.

inputs_params:
  - Required: Path or identifier of the template file:
    - {template_path} or {template_name} within a known folder.
    - Supported types: typically .docx, .txt, or .md.
  - Required: Party and project data:
    - {party_A_name}, {party_A_address}, {party_A_role}
    - {party_B_name}, {party_B_address}, {party_B_role}
    - {project_name}, {project_description}
    - {effective_date}, {term_description}, {payment_terms}, {governing_law}, etc.
  - Required: Output preferences:
    - {output_directory} (where to save generated contracts).
    - {output_file_basename} pattern (e.g., {contract_type}_{party_A_name}_{date_time}).
    - Desired primary output format: docx, text/markdown, or both.
  - Optional: Whether to also generate a PDF version.
  - Optional: Placeholder style/confirmation:
    - A list of expected placeholders (e.g., ["{PARTY_A_NAME}", "{PARTY_B_NAME}", "{PROJECT_NAME}", ...]) if the user has it.
  - Optional: Whether to allow leaving unknown placeholders unchanged (default: no; treat unknown placeholders as an issue to flag).

context:
  reasoning:
    - Keep the workflow simple: confirm which template and which data to inject, run a single script to perform replacements, and optionally convert to PDF.
    - Use placeholder tokens in the template like {PARTY_A_NAME}, {PARTY_B_NAME}, {PROJECT_NAME}, {EFFECTIVE_DATE} that can be reliably replaced with plain text.
    - Prefer "create and run python script" to:
      - Load the template file.
      - Apply a mapping of placeholders → user-provided values in one pass.
      - Write the filled contract to {output_contract_path}.
      - Optionally check for unresolved placeholders.
    - Use existing document actions when helpful:
      - For text/markdown templates: simple string replacement and save.
      - For .docx templates: use python-docx from inside the script (installed via pip) to replace text while keeping basic formatting.
    - Only run a PDF conversion step if the user wants PDF output (using "convert_to_pdf" or "create pdf file" depending on source format).
    - Run basic validation by checking:
      - The file exists at {output_contract_path}.
      - There are no remaining {PLACEHOLDER}-style tokens unless explicitly allowed.
    - Keep to a small number of calls: one main script for filling, optionally one action for PDF export, plus messages.

  deadline: {time_left} left until deadline {deadline}

  definition_of_done(check during final validation step):
    - A contract file exists at {output_contract_path} in the requested primary format.
    - All required placeholders provided by the user are correctly filled with the supplied party and project data.
    - No unexpected placeholder tokens like {SOME_FIELD} remain in the final document, unless the user explicitly allowed them.
    - If PDF output was requested, a PDF exists at {output_pdf_path}.
    - The user has received a summary message containing:
      - Template used.
      - Parties and project name.
      - Output file path(s) and format(s).
    - There are no unhandled script errors.

  avoid:
    - Guessing values for legally relevant fields (e.g., dates, amounts) without user-provided data; always ask instead.
    - Modifying or overwriting the original template file.
    - Using GUI mode for this task; text-based CLI operations are sufficient.
    - Running multiple complex passes over the same file when a single, clear replacement pass is enough.
    - Leaving the user unaware of unresolved placeholders or missing data.

steps:
  name: Confirm template and data inputs
  description: Make sure the agent has a clear template source and all key data fields needed to fill the contract.
  action_instruction: >
    Use "send_message" to confirm:
    - {template_path} or {template_name} and where it is stored (e.g., "{template_directory}" or workspace).
    - Whether the template is .docx, .txt, or .md (if not obvious from extension).
    - The key fields for the contract:
      - {party_A_name}, {party_B_name}, {project_name}, {effective_date}, plus any other special terms (e.g., {payment_terms}, {governing_law}).
    - {output_directory} and desired {output_file_basename} pattern. A simple default might be:
      - {contract_type}_{party_A_name}_{date}.docx
    - Desired formats:
      - docx only, text/markdown only, or docx + pdf.
    - Whether unknown placeholders should be left unchanged or treated as an error.
    Ask the user to fill any missing mandatory fields (e.g., effective date or party names) using "send_message" where necessary, each focused on one missing item.
    Once they respond, send a concise "send_message" summarizing:
    - Template: {template_path}
    - Output directory: {output_directory}
    - Output formats: {output_format}
    - Main party/project fields and values.
  validation_instruction: >
    Ensure that:
    - A valid-looking {template_path} or {template_name} is provided.
    - The main party and project fields are non-empty:
      - {party_A_name}, {party_B_name}, {project_name}, {effective_date}
    - An {output_directory} is known (e.g., workspace or a specific folder).
    - At least one output format is chosen (docx and/or pdf or text).
    If any of these are missing, use "send_message" to obtain them and do not move on until they are clearly defined.

  name: Locate and verify template file
  description: Check that the template file exists and is readable, and optionally inspect for placeholder patterns.
  action_instruction: >
    Use "find file by name" or "list folder" as needed:
    - If the user gave an exact {template_path}, you can skip searching and just rely on that path.
    - Otherwise, use "find file by name" with {template_name} (e.g., "service_agreement_template*.docx") and confirm the resolved path via "send_message".
    Once the path {template_path} is known:
    - If it's a .docx file and confirmation is needed, you may use "read word file" to extract text and quickly verify that expected placeholders
      like {PARTY_A_NAME}, {PARTY_B_NAME}, {PROJECT_NAME}, {EFFECTIVE_DATE} are present in the content.
    - If it's a .txt or .md file, you can also read it via a short "create and run python script" or similar to verify placeholders.
    If the file is missing or unreadable, send a short "send_message" explaining the issue and ask the user to correct {template_path}.
  validation_instruction: >
    Confirm that:
    - {template_path} points to an existing file with an expected extension (.docx, .txt, .md).
    - The file is readable (no permission errors).
    - At least a subset of expected placeholder tokens is present (e.g., {PARTY_A_NAME}, {PARTY_B_NAME}, {PROJECT_NAME}).
    If the template cannot be found or appears to contain no placeholders at all, notify the user via "send_message" and either:
    - Ask them to provide a corrected template, or
    - Use "mark task error" if they cannot supply a usable template.

  name: Generate filled contract document
  description: Run a single script that loads the template, replaces placeholders with the provided data, and creates a filled contract file.
  action_instruction: >
    Use "create and run python script" with code that:
    - Accepts:
      - template_path = {template_path}
      - output_directory = {output_directory}
      - output_file_basename = {output_file_basename}
      - data mapping: a dictionary like
        {
          "{PARTY_A_NAME}": {party_A_name},
          "{PARTY_B_NAME}": {party_B_name},
          "{PROJECT_NAME}": {project_name},
          "{EFFECTIVE_DATE}": {effective_date},
          ...
        }
      - a flag for unknown_placeholder_behavior = "error" or "leave" depending on user preference.
    - Constructs output_contract_path:
      - e.g., output_directory + "/" + output_file_basename + ".docx" (or ".txt"/".md" for text).
    - Detects the template extension:
      - If .docx:
        - Install python-docx inside the script if not present (using subprocess + pip).
        - Open the document and replace placeholder text in paragraphs and runs for each key in the mapping.
      - If .txt or .md:
        - Read the file as text.
        - For each placeholder in the mapping, apply simple string replacement.
    - After replacements:
      - Optionally scan the resulting text/content for remaining {SOMETHING} patterns:
        - If unknown_placeholder_behavior == "error" and unresolved tokens are found, log them and exit with an error status message.
      - Save the filled contract to output_contract_path.
    - Print to stdout:
      - output_contract_path
      - Any unresolved placeholders detected.
      - Simple status line, e.g., "STATUS: OK" or "STATUS: ERROR: <message>".
  validation_instruction: >
    Check the action output:
    - status should indicate success, or at least no unhandled exceptions.
    - stdout should mention output_contract_path.
    - If the script reported unresolved placeholders and unknown_placeholder_behavior was "error", treat this as a problem:
      - Use "send_message" to show the list of unresolved tokens and ask the user whether to:
        - Provide values for them, or
        - Accept leaving them unchanged and rerun with unknown_placeholder_behavior="leave".
    If the script completed successfully and output_contract_path exists, proceed to the optional PDF step (if requested) or directly to final validation.

  name: Optional PDF export
  description: If requested, convert the filled contract into a PDF version.
  action_instruction: >
    If the user asked for a PDF:
      - If the primary output is .docx:
        - Use the "convert_to_pdf" action with:
          - input_file = {output_contract_path}
          - output_pdf = {output_pdf_path}
      - If the primary output is markdown/text:
        - Use "create pdf file" with:
          - file_path = {output_pdf_path}
          - content = the filled contract text (pass either original text or re-read from {output_contract_path}).
    Keep this step simple: one conversion action, no extra formatting passes beyond what the actions already handle.
  validation_instruction: >
    Verify that:
    - The PDF conversion action returns a success status.
    - {output_pdf_path} is non-empty and reported by the action.
    If conversion fails, inform the user via "send_message" and let them know that the docx/text contract is still available; they may choose to retry or accept only the primary format.

  name: Final check and report to user
  description: Perform a minimal final validation and inform the user where the generated contract(s) are stored, then close the task.
  action_instruction: >
    Perform a simple final check using "create and run python script" or "shell view" if needed:
      - Confirm that {output_contract_path} exists.
      - If requested, confirm that {output_pdf_path} exists.
    Then use "send_message" to give the user a concise summary:
      - Template used: {template_path}
      - Parties: {party_A_name} and {party_B_name}
      - Project: {project_name}
      - Effective date: {effective_date}
      - Output file(s):
        - Primary contract: {output_contract_path}
        - PDF (if generated): {output_pdf_path}
      - Note any unresolved placeholders that the user explicitly allowed to remain.
    If everything matches the definition_of_done:
      - Call "mark task completed" with a short message referencing {output_contract_path} (and {output_pdf_path}, if any).
    If the user chooses to stop because the template or data were insufficient:
      - Call "mark task cancel" with a brief reason.
    If repeated errors prevented generating a usable contract:
      - Call "mark task error" with a short explanation and any partial output paths, so the user can inspect them if desired.
