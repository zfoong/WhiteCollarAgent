name: Source control change summarization
description: Read version-control (e.g., Git) commit history in a repository and produce a concise, human-readable summary of key changes over a specified range (by date, tags, or number of commits). Use simple CLI-based operations and one main summarization script.

goal/outcome:
  - A clear, human-readable summary of changes in {repo_path} over the specified range (e.g., {from_ref}..{to_ref}, since {since_date}, or last {max_commits} commits).
  - Summary focuses on key changes: features, bug fixes, refactors, breaking changes, and notable file or directory impacts.
  - Optional filters (e.g., author, paths/components) are respected if provided.
  - A text/markdown summary file is created in the workspace at {summary_file_path}.
  - Optional: a raw commit log snapshot is saved at {raw_log_file_path} for traceability.
  - The user receives a short message summarizing scope (range, filters) and where to find the detailed summary file.

inputs_params:
  - Required: Repository path {repo_path} (must point to a valid SCM repo, e.g., a Git repo with a .git folder).
  - Required: Change range specification, such as:
    - Last {max_commits} commits, or
    - A date range (since {since_date}, until {until_date}), or
    - A ref range {from_ref}..{to_ref} (e.g., tag1..tag2 or main..feature-branch).
  - Optional: Target branch or ref {branch_or_ref} (default: current HEAD of the repo).
  - Optional: Author filter {author_filter} (e.g., commits by a specific author).
  - Optional: Path/component filters {component_paths} (e.g., only summarize changes under src/, api/, docs/).
  - Optional: Detail level {detail_level} (e.g., "brief", "normal", "detailed").
  - Optional: Output format {output_format} (e.g., "markdown", "plain_text"), default markdown.
  - Optional: Maximum number of commits {max_commits} (safety limit even if a broader range is chosen).

context:
  reasoning:
    - Keep the workflow minimal:
      1) Confirm repo and range.
      2) Use git CLI via "shell exec" to extract raw history.
      3) Use a single "create and run python script" action to parse and summarize.
      4) Save summary to a single file and send a concise report.
    - Use Git (or equivalent SCM) via CLI commands from {repo_path}, assuming Git is installed.
    - For Git:
      - Use "shell exec" to run commands like:
        - git -C {repo_path} log {range} --numstat --date=iso --pretty=...
      - Include commit hash, author, date, subject, and optionally files changed with insertions/deletions.
    - Let the Python script:
      - Parse the raw log text.
      - Group commits by type keywords in messages (e.g., feat, fix, refactor, docs) when possible.
      - Highlight:
        - New features, bug fixes, breaking changes (if commit messages mention "BREAKING" or similar).
        - Most frequently touched directories or files.
        - Approximate magnitude of changes (e.g., number of commits, files, added/removed lines).
      - Produce a markdown/plain-text summary with sections like:
        - Overview
        - Highlights
        - Notable changes by area
        - Commit statistics
      - Write the summary to {summary_file_path}.
    - Keep assumptions simple and configurable via placeholders; do not add extra stages like complex statistics or diagrams unless requested.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The repository at {repo_path} was recognized as a valid SCM repository (e.g., Git repo).
    - A raw commit log was successfully retrieved for the specified range or limit.
    - A summary file exists at {summary_file_path} and is non-empty.
    - The summary clearly states:
      - Repo path and change range.
      - Number of commits summarized.
      - Key categories of changes (features, fixes, etc.) where applicable.
    - The user has received a short message with:
      - The summarized range and filters.
      - Where to find the summary file.
  avoid:
    - Running many small commands per commit; instead, use a single log command plus one summarization script.
    - Relying on GUI tools; CLI is sufficient.
    - Over-parsing or enforcing a specific commit message convention beyond simple keyword detection.
    - Trying to annotate or modify the repository; this task is read-only.
    - Failing silently if git commands error; always surface an explanation to the user.

steps:
  name: Confirm repository and change range
  description: Ensure the agent knows which repository to inspect, what range of commits to summarize, and any filters or detail preferences.
  action_instruction: >
    Use "send_message" to restate and confirm:
    - Repository path: {repo_path}.
    - Range spec: one of:
      - Last {max_commits} commits, or
      - Since {since_date} (and optionally until {until_date}), or
      - Ref range {from_ref}..{to_ref}.
    - Optional: Target branch/ref {branch_or_ref} if user wants a specific branch.
    - Optional: Filters (author {author_filter}, paths {component_paths}).
    - Optional: Detail level {detail_level} and output format {output_format}.
    Ask the user to confirm or clarify any missing items. If a critical item is missing
    (e.g., how many commits or what date range), use "send_message" with a focused prompt such as:
    "Should I summarize the last {default_max_commits} commits on the current branch of {repo_path}?"
    Once the user confirms, send a short "send_message" that records the final agreed parameters using placeholders
    like {repo_path}, {range}, {filters}, and {max_commits} in the text so they are explicit in the task history.
  validation_instruction: >
    Ensure that:
    - {repo_path} is provided and appears to be a valid local path string.
    - A range strategy is decided: either {max_commits} or {since_date}/{until_date} or {from_ref}..{to_ref}.
    - If none is explicitly provided, default to a safe choice (e.g., last {default_max_commits} commits)
      but only after confirming this default with the user via "send_message".
    Proceed only when these parameters are clear.

  name: Collect commit history via CLI
  description: Use a single Git command (or minimal set of commands) to fetch the raw commit history text for the requested range.
  action_instruction: >
    Use "shell exec" to run a Git command from {repo_path}. For example (using placeholders):
    - command: git -C "{repo_path}" log {range_args} --date=iso --numstat --pretty=format:"%H%n%an%n%ad%n%s%n%b%n---"
      where {range_args} is constructed based on the user inputs:
      - For last {max_commits} commits: -n {max_commits} {branch_or_ref}
      - For date range: --since="{since_date}" [--until="{until_date}"] {branch_or_ref}
      - For ref range: {from_ref}..{to_ref}
      Optionally add:
      - --author="{author_filter}" if provided.
      - path filters at the end if {component_paths} are provided.
    Keep "shell exec" parameters simple:
    - "shell": e.g., "powershell" or default shell,
    - "cwd": {repo_path},
    - "timeout": a reasonable value for the size of the log.
    Capture stdout as the raw log text and stderr for errors.
    If the command fails (non-zero return_code), later steps will handle it.
    Optionally, write the raw log text to a file {raw_log_file_path} via a short "create and run python script"
    or by embedding file write in the same script, but keep it minimal; this is optional.
  validation_instruction: >
    Check the "shell exec" output:
    - return_code == 0 and stdout is non-empty.
    - If return_code != 0 or stdout is empty:
      - Use "send_message" to explain that git log failed, including a short excerpt from stderr.
      - Ask the user to confirm {repo_path} or adjust range/filters (e.g., invalid ref or branch).
      - If the issue cannot be resolved (e.g., not a git repo), use "mark task error" with a brief explanation.
    Proceed only if valid log text is available.

  name: Generate human-readable summary
  description: Parse the raw commit log and create a user-friendly summary focusing on key changes and statistics.
  action_instruction: >
    Use "create and run python script" with code that:
    - Receives:
      - Raw git log text (either passed directly in the script or read from {raw_log_file_path}).
      - Parameters: {detail_level}, {output_format}, and any filter labels used for context (e.g., {repo_path}, {range_description}).
    - Parses the log using the known separator (e.g., "---" between commits and fixed line order for hash/author/date/subject/body).
    - For each commit:
      - Extract:
        - commit_hash,
        - author,
        - date,
        - subject,
        - (optional) body,
        - (optional) file changes via the --numstat lines (insertions/deletions and file names).
      - Optionally categorize commits by keywords in subject/body:
        - "feat", "feature" → Features.
        - "fix" → Bug fixes.
        - "refactor" → Refactors.
        - "docs" → Documentation.
        - "test" → Tests.
        - "BREAKING" → Breaking changes.
    - Aggregate:
      - Total number of commits.
      - Number of commits per category (feature, fix, refactor, etc.).
      - Top {top_n} directories or files by frequency of change (if {detail_level} is not "brief").
      - Approximate lines added/removed (sum of numstat values) if available.
    - Construct a markdown or plain-text summary (based on {output_format}) with sections such as:
      - Title: "Change Summary for {repo_path} ({range_description})"
      - Overview (range, number of commits, authors if relevant).
      - Highlights: bullet points of the most important features/fixes/breaking changes (where keywords exist).
      - Changes by category (short bullet list).
      - Notable areas impacted (key directories/files).
      - Simple commit statistics.
    - Write the summary to {summary_file_path} in the workspace using Python file I/O.
    - Print to stdout:
      - {summary_file_path},
      - number of commits summarized,
      - a short 2–3 line overview that can be reused directly in the final "send_message".
  validation_instruction: >
    Check the script result:
    - status indicates success (no unhandled exception).
    - stdout mentions a {summary_file_path}.
    - Summary file is expected to be non-empty; if the script prints an indication of zero commits, notify the user via "send_message".
    If the script fails:
    - Use "send_message" to explain that summarization failed, include a short error note, and decide
      whether to quickly fix the script and retry once, or call "mark task error" if not reasonable.

  name: Overall validate summarization
  description: Perform a simple final check that the summary matches the intended scope and is usable by the user.
  action_instruction: >
    Perform minimal checks using the script outputs:
    - Ensure the number of commits summarized is consistent
