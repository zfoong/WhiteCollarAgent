name: PDF merging
description: Merge multiple PDF files into a single output PDF in a specified order, using a simple, efficient CLI-based script and minimal supporting actions.

goal/outcome:
  - A single merged PDF file created at {output_pdf_path} that combines all specified input PDFs.
  - The pages appear in the exact order defined by the user (or a clearly documented default ordering).
  - All input PDFs are preserved by default (no deletion) unless the user explicitly requests otherwise.
  - The merged PDF is valid, non-empty, and can be opened by standard PDF viewers.
  - A small log (text or CSV) is created at {log_file_path} listing input files, merge order, output file path, and basic status.
  - The user receives a concise summary: which PDFs were merged, the order used, and where the merged file and log are stored.

inputs_params:
  - Required: A list of input PDF file paths in the desired order (e.g., [{pdf_1_path}, {pdf_2_path}, ...]) OR:
    - A root folder {input_directory} plus a simple ordering rule (e.g., sort by filename ascending).
  - Required: Output merged PDF file path {output_pdf_path} (e.g., {workspace_path}/{merged_file_name}.pdf).
  - Optional: Whether to include PDFs from subfolders under {input_directory} (recursive: true/false).
  - Optional: Simple include pattern (e.g., "*.pdf") and/or exclude pattern (e.g., "*_backup.pdf") when using a directory-based selection.
  - Optional: Whether to delete or move original PDFs after successful merge (default: keep originals).
  - Optional: Dry-run flag (only list planned merge order and output path, no actual merge).

context:
  reasoning:
    - Keep the workflow short: confirm inputs and order, resolve actual PDF paths, run one script to merge, then validate and report.
    - Prefer a single "create and run python script" call for resolving files and merging, to minimize overhead.
    - When only a folder is given, apply a clear, simple rule (e.g., sort by filename) and show that to the user before merging if there is any ambiguity.
    - Use Python (via "create and run python script") and install a lightweight PDF library (e.g., pypdf) inside the script if needed.
    - Perform basic validation at the end: ensure the merged file exists, is non-empty, and has at least as many pages as the total of all input PDFs.
    - Use "send_message" sparingly but clearly: once to confirm parameters, once to present final results.
    - Avoid GUI mode; CLI/script is sufficient.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The merged file exists at {output_pdf_path}, is non-empty, and is reported as a valid PDF by the script and/or "read pdf file".
    - The number of pages in the merged PDF is equal to the sum of pages from all input PDFs that were successfully processed.
    - The order of input PDFs used for merging matches the user’s specified list or the documented ordering rule.
    - The log at {log_file_path} lists all input PDFs, the applied order, final output path, and a simple status (success/error).
    - The final "send_message" includes a clear summary and the output/log paths.
  avoid:
    - Guessing complex ordering rules; if order is unclear, ask once and then keep it simple.
    - Doing multiple passes over the same files when one script can handle discovery, ordering, and merging.
    - Deleting or moving original PDFs unless explicitly requested by the user.
    - Using GUI mode or extra backup/archiving steps unless the user asks for them.

steps:
  name: Confirm input PDFs and output file
  description: Ensure which PDFs to merge, in what order, and where the merged file should be saved.
  action_instruction: >
    Use the "send_message" action to confirm:
    - Whether the user will provide an explicit ordered list of PDF paths (e.g., [{pdf_1_path}, {pdf_2_path}, ...]),
      OR a folder {input_directory} from which all PDFs should be merged.
    - If a folder is used:
      - Whether to include subfolders (recursive: true/false).
      - A simple ordering rule (e.g., sort by filename ascending, or sort by modification time).
      - Any include/exclude pattern for filenames (e.g., include "*.pdf", exclude "*_backup.pdf").
    - The desired output path {output_pdf_path} for the merged PDF (e.g., {workspace_path}/{merged_file_name}.pdf).
    - Whether to keep all original PDFs (default) or delete/move them after a successful merge.
    - Whether the user wants a dry-run first (just list the planned merge order and output path, no merge).
    Ask the user to correct or fill in missing items. If a critical detail is unclear (e.g., input order or output path),
    use "send_message" once with a focused question. After receiving answers, send a short "send_message"
    summarizing the final agreed parameters (inputs, order rule, output path, and whether it's a dry-run).
  validation_instruction: >
    Before proceeding, confirm that:
    - There is either:
      - A non-empty ordered list of input PDF paths {input_pdf_paths}, or
      - A valid-looking {input_directory} plus a clear ordering rule.
    - {output_pdf_path} is specified (or easily derivable from {merged_file_name} in a known directory, e.g., {workspace_path}).
    - The default behavior for originals (keep vs delete/move) is explicit.
    - Dry-run vs actual merge is decided.
    If any of these are missing or conflicting, call "send_message" again, then update the summary via "send_message".
    Proceed only when parameters are clearly confirmed.

  name: Resolve and validate input PDF files
  description: Resolve the actual list of input PDF paths based on the user’s parameters and perform basic validation (existence and non-empty).
  action_instruction: >
    Use "create and run python script" with a small script that:
    - Accepts the parameters:
      - Either:
        - explicit_input_paths = {input_pdf_paths}, or
        - input_directory = {input_directory}, recursive flag, include/exclude patterns, and ordering rule.
    - If explicit_input_paths are given:
      - Normalize each path to an absolute path.
      - Check that each file exists and has a ".pdf" extension.
      - Collect only those that exist and are regular files; record missing ones in a simple in-memory error list.
    - If a directory is given:
      - Traverse it (os.walk if recursive, or os.listdir if not).
      - Select files matching "*.pdf" and any include/exclude patterns.
      - Sort the resulting list according to the ordering rule (e.g., by filename).
    - Print to stdout:
      - The final ordered list of PDF paths (one per line or a simple numbered list).
      - Basic counts (total files found, missing/invalid if any).
    - Optionally, if dry_run is True, you can stop here after printing the order and not yet merge (the next step will check dry_run).
  validation_instruction: >
    Check the script’s status (from "create and run python script"):
    - It should complete without unhandled exceptions.
    - There should be at least one valid input PDF path in the final list.
    - If any specified PDFs are missing or invalid, send a short "send_message" to the user summarizing which ones were skipped.
    If no valid PDFs remain, inform the user via "send_message" and stop the task, or ask for corrected inputs.
    If dry_run was requested solely to preview order:
      - Use "send_message" to show a compact list of the resolved order and ask the user to confirm before actual merging.

  name: Merge PDFs
  description: Merge the validated input PDF files into a single output PDF in the confirmed order using one script call.
  action_instruction: >
    If the user confirmed to proceed (and dry_run is False):
      - Use "create and run python script" again with code that:
        - Installs or imports a simple PDF library if needed (e.g., run "pip install pypdf" via subprocess once inside the script).
        - Loads the final ordered list of PDF paths from parameters (or reuses logic from the previous step in the same script for simplicity).
        - For each input PDF:
          - Open it with the PDF library.
          - Append all its pages to a merger/reader object in order.
        - Write the merged output to {output_pdf_path}.
        - Optionally compute:
          - total_input_pages (sum of pages from all input PDFs),
          - merged_pages (pages in the output file).
        - Create a simple log string or CSV text that includes:
          - {output_pdf_path},
          - list of input PDFs in order,
          - total number of input files,
          - total_input_pages, merged_pages,
          - timestamp {date_time}.
        - Write this log to {log_file_path} using normal Python file I/O.
        - Print to stdout:
          - "MERGE_SUCCESS" or "MERGE_FAILED" with a simple reason.
          - total_input_pages and merged_pages.
          - Paths to {output_pdf_path} and {log_file_path}.
    If the user only wanted a dry-run:
      - Do not perform this step; instead, move on to the final reporting to explain that no merge was executed.
  validation_instruction: >
    Inspect the output of "create and run python script":
    - Status must indicate success (no unhandled exceptions).
    - "MERGE_SUCCESS" should appear in stdout.
    - {output_pdf_path} and {log_file_path} should be mentioned.
    - The reported merged_pages should be >= 1 and ideally equal to total_input_pages (if all inputs were valid).
    If "MERGE_FAILED" or an error is present, send a short "send_message" to the user explaining the error and
    decide (with user input if necessary) whether to retry (e.g., after removing a broken PDF) or stop the task.

  name: Validate merged PDF (lightweight)
  description: Perform a simple but sufficient validation that the merged PDF is readable and matches expectations.
  action_instruction: >
    Use a small, fast check:
    - Either:
      - Use "read pdf file" on {output_pdf_path} to ensure the PDF can be parsed and obtain a page count from the content metadata, OR
      - Use another "create and run python script" to:
        - Open {output_pdf_path} with the same PDF library.
        - Get the number of pages.
        - Print the page count and a simple "VALID_PDF" marker.
    - Confirm that:
      - The page count is at least 1.
      - If available, the page count matches the merged_pages reported earlier.
  validation_instruction: >
    Ensure that:
    - Validation completed without error (PDF was readable).
    - The reported page count makes sense and aligns with expectations.
    If validation fails, notify the user via "send_message" that the merged file appears corrupted or unreadable,
    and mark the task as error or rerun merge if the cause is obvious (e.g., a single problematic input PDF).

  name: Close task and report to user
  description: Summarize the merge result, expose relevant paths, and mark the task status.
  action_instruction: >
    Use "send_message" to provide a concise final summary:
    - Whether this was a dry-run or an actual merge.
    - The number of input PDFs merged and the final ordered list (possibly abbreviated if long).
    - The final page count of the merged PDF (if available).
    - The location of the merged file {output_pdf_path}.
    - The location of the log file {log_file_path}.
    - Whether any input PDFs were skipped or caused errors.
    If the merge and validation succeeded:
      - Call "mark task completed" with a short message summarizing success and listing {output_pdf_path}.
    If the user chose to stop after dry-run (no merge executed):
      - Call "mark task cancel" with a brief message indicating it ended after preview only (no files changed).
    If the merge could not be completed due to persistent errors:
      - Call "mark task error" with a short explanation and the log path so the user can inspect which inputs failed.
