name: Full folder backup to local or network locations
description: Create or update a full backup of one or more source folders to local or network destinations, and optionally save selected reports as PDF before or during the backup. Use simple, efficient CLI-based operations with minimal passes and a single backup log.

goal/outcome:
  - One or more source folders {source_roots} are fully backed up to one or more destinations {backup_destinations}, which may be local paths (e.g., C:\Backups\...) or network paths (e.g., \\server\share\...).
  - All specified report files (e.g., .txt, .md, .docx) are saved as PDFs (or confirmed already in PDF form) before the backup completes.
  - The backup preserves folder structure, file contents, and timestamps as much as practical (best effort via copy method).
  - No files outside the specified {source_roots} are copied.
  - A single backup log file {backup_log_path} exists in the workspace mapping each copied file:
    - source_path
    - destination_path
    - status (copied/skipped/error)
    - optional notes or errors.
  - The user receives a concise summary including:
    - Source folders, destinations, and backup time {backup_time}.
    - Whether PDF reports were created/updated.
    - Total files and approximate size copied.
    - Path to the backup log file.

inputs_params:
  - Required: One or more source root folders {source_roots} to back up.
  - Required: One or more backup destinations {backup_destinations}:
    - Local folders (e.g., C:\Backups\ProjectA).
    - Network shares (e.g., \\server\share\ProjectABackup).
  - Required: Backup mode:
    - mirror: overwrite/update files in destination so it matches source (no deletes unless user explicitly requests).
    - copy_only: only copy new/missing files, do not delete or modify existing destination files.
  - Required: Decision on report-to-PDF handling:
    - Which files or patterns represent “reports” that should be saved as PDF (e.g., files in {reports_folder}, or files matching *.md, *.txt, *.docx).
    - Whether to always regenerate PDFs or only if missing.
  - Optional: Exclusion rules for backup (e.g., skip certain subfolders, temporary files, cache directories).
  - Optional: Size or type filters (e.g., skip files larger than {size_limit} if user wants).
  - Optional: Dry-run flag for backup (list and log what would be copied without doing actual copy).
  - Optional: Safety cap (maximum number of files or total size to process before asking user for confirmation).

context:
  reasoning:
    - Keep the workflow direct:
      - Confirm scope and backup policy.
      - Optionally convert specified reports to PDF.
      - Run a single script to copy directory trees from each {source_root} to each {backup_destination}.
      - Log everything in one backup log file.
    - Prefer CLI path via "create and run python script" for both PDF conversion coordination and copy operations; avoid GUI and avoid multiple redundant scans.
    - For reports:
      - Use file patterns or explicit paths from the user.
      - For files that are not yet PDF:
        - Use "convert_to_pdf" when the input is a .txt/.md/.docx file (if available and convenient), or
        - Use "create pdf file" when content is prepared as Markdown or text in a single step.
      - Keep this step simple: only process the list/patterns user cares about; do not try to “discover” every possible report.
    - For backup:
      - Use a single "create and run python script" call to:
        - Walk each {source_root}.
        - Apply exclude filters.
        - Map each source path to a destination path under {backup_destination}.
        - Copy files using shutil.copy2 or similar, preserving metadata when possible.
        - Respect mode (mirror vs copy_only) in a straightforward way (e.g., mirror can overwrite, copy_only avoids overwrites).
        - Log file-level results to {backup_log_path}.
      - If network paths are used, treat them as normal paths (UNC) in Python and catch errors (e.g., permissions, unreachable).
    - At the end, use the log and simple counts from stdout to summarize for the user, without complex post-validation passes.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - All specified {source_roots} have been processed according to the chosen backup mode.
    - For each source file considered in scope:
      - Either:
        - It has a corresponding copy in at least one {backup_destination}, or
        - It was intentionally skipped with justification (e.g., excluded by pattern, error logged).
    - Report files have corresponding PDF versions in the expected location(s), or the user explicitly opted out of PDF generation.
    - No unintended paths outside {source_roots} were touched.
    - No existing files in destinations were overwritten contrary to the agreed mode (copy_only vs mirror).
    - A single backup log file {backup_log_path} exists in the workspace, and the final message references it.
  avoid:
    - Introducing extra layers such as compression/archiving unless the user explicitly asks (e.g., ZIP backup).
    - Multiple deep rescans of the same trees; one main traversal per backup run is enough.
    - Using GUI mode; CLI is sufficient.
    - Deleting files from destination unless user explicitly requests destructive mirror behavior.
    - Attempting complicated incremental backups; keep it to straightforward copy/update.

steps:
  name: Confirm backup scope and policy
  description: Collect and confirm what to back up, where to back it up, and how to handle report PDFs and overwrite behavior.
  action_instruction: >
    Use the "send_message" action to restate and confirm:
    - Source root folder(s) {source_roots} to include in the backup.
    - Backup destination(s) {backup_destinations}, including whether they are local or network paths.
    - Backup mode:
      - "mirror": allow overwriting destination files when the source has newer or different files (no deletes unless explicitly requested).
      - "copy_only": only copy new/missing files; do not overwrite any existing files.
    - Report handling:
      - Which files or patterns represent reports (e.g., all *.md *.txt *.docx in {reports_folder}, or a specific list).
      - Whether to generate/refresh PDFs for these reports as part of the backup.
    - Any exclude rules (paths or patterns to skip) for the backup.
    - Optional size/type filters (if the user wants to exclude very large or certain types of files).
    - Whether they want a dry-run first (listing/logging what would be copied) or to run the actual backup immediately.
    - Any safety cap (e.g., "stop and ask if more than {max_files} files or {max_total_size} GB").
    Ask the user to confirm or adjust these. If critical items are unclear (e.g., destination or mode), use "send_message" with a focused
    question. Once the user clarifies, send a short "send_message" summarizing the final parameters so they are clear in the task history.
  validation_instruction: >
    Check that:
    - At least one {source_root} is specified.
    - At least one {backup_destination} is specified.
    - Backup mode is clearly chosen ("mirror" or "copy_only").
    - The decision around report PDFs is known (e.g., "generate PDFs for all reports matching {pattern}" or "skip PDF generation").
    - Dry-run vs actual backup is decided.
    If any of these are missing or inconsistent, use "send_message" again. Only proceed once the user confirms.

  name: Save selected reports as PDF (if requested)
  description: Convert specified report files into PDF format before (or as part of) the backup, in a simple and direct way.
  action_instruction: >
    If the user chose to generate PDFs for reports:
      - Identify the report sources based on the agreed patterns or explicit list (e.g., "*.md" in {reports_folder} under {source_roots}).
      - For a small or moderate report set, use "create and run python script" to:
        - Walk the relevant report directory/ies or handle explicit file paths.
        - For each report file:
          - Determine if it already has a corresponding PDF {report_pdf_path} (e.g., same name but with .pdf).
          - If PDF generation is needed:
            - If the source is .txt, .md, or .docx:
              - Option 1 (simpler, if acceptable): Call the "convert_to_pdf" action separately per file outside this script, with:
                - input_file = {report_source_path}
                - output_pdf = {report_pdf_path}
              - Option 2 (if sticking to a single script is preferred): The script prepares a list of report files and prints them;
                then the agent invokes "convert_to_pdf" in a loop for those files.
            - Keep behavior simple: convert only the files that match patterns, do not try to parse or rewrite content.
        - Print a small summary to stdout: number of report files, number of PDFs created/updated.
      - For many reports, use simple filtering rules and avoid unnecessary processing (e.g., skip if the PDF already exists and user does not require refresh).
    If the user skipped PDF generation, do nothing in this step.
  validation_instruction: >
    If report PDFs were requested:
      - Ensure there is no error status from "convert_to_pdf" calls.
      - If the script or actions fail repeatedly, send a short "send_message" explaining which report(s) failed.
    If there are only a few reports, it is sufficient to rely on action statuses and the final backup log; no extra scans are needed.
    If the user opted out of PDF generation, this step requires no validation beyond acknowledging that decision.

  name: Run backup copy to destination(s)
  description: Perform the folder backup itself in one pass using a Python script, copying files from {source_roots} to {backup_destinations} and logging results.
  action_instruction: >
    Use "create and run python script" with code that:
      - Accepts:
        - source_roots = {source_roots}
        - backup_destinations = {backup_destinations}
        - backup_mode = {backup_mode} ("mirror" or "copy_only")
        - exclude_patterns and/or exclude_paths (if any)
        - dry_run flag
        - safety caps {max_files}, {max_total_size_bytes} (if provided)
        - backup_log_path = {backup_log_path} (e.g., "backup_log_{date_time}.csv" in workspace)
      - For each source_root:
        - Verify it exists and is a directory; if not, record a message (logged and printed) and continue.
      - For each source_root and each file under it (via os.walk):
        - Skip directories or files that match excluded paths or patterns.
        - For each included file:
          - For each backup_destination:
            - Compute a relative path from {source_root} to the file (e.g., via os.path.relpath).
            - Build dest_path = backup_destination + relative_path.
            - If dry_run is True:
              - action = "would_copy".
            - If dry_run is False:
              - Ensure the destination directory exists (os.makedirs).
              - If backup_mode == "copy_only" and dest_path already exists:
                - action = "skipped_exists".
              - Else (mirror or dest missing):
                - Copy the file using shutil.copy2 (best effort to preserve metadata).
                - action = "copied".
          - Track count and approximate total size; if safety caps are exceeded, stop further processing and note this in summary.
          - For each (source_path, dest_path) pair, append a log entry:
            - source_path, dest_path, action, error_message (if any).
      - At the end:
        - Write the log file to {backup_log_path}.
        - Print to stdout:
          - Number of source_roots visited.
          - Number of files processed.
          - Total approximate size copied (or would be copied).
          - Counts per action (copied/skipped_exists/would_copy/error).
          - The log file path {backup_log_path}.
  validation_instruction: >
    Inspect the script output:
    - Ensure there is no unhandled exception (status should be success).
    - Confirm it printed a summary including counts and {backup_log_path}.
    - If it reports zero files processed but the user expected more, use "send_message" to explain and ask if exclude patterns
      or paths need adjustment.
    - If a safety cap was triggered, make sure this is mentioned to the user.
    For dry-run:
      - Confirm that actions recorded are of type "would_copy" or "skipped_exists" only.
    For actual backup:
      - Confirm that at least some "copied" actions are present when expected.

  name: Overall validate backup
  description: Make a simple final check that the backup actions align with expectations and that the log is consistent.
  action_instruction: >
    Use either "shell view" or a small "create and run python script" to:
      - Open {backup_log_path}.
      - Count total lines (excluding header if present).
      - Count how many entries have actions "copied", "skipped_exists", "would_copy", and "error".
    Confirm that:
      - The total entries roughly match the counts reported in stdout.
      - Errors, if any, appear reasonable and are not dominant (e.g., most files are successfully copied or would be copied).
    No extra directory scans are necessary unless something is clearly inconsistent (e.g., log is empty but script reported copies).
  # No separate validation_instruction is needed beyond this small consistency check.

  name: Close task and report to user
  description: Present the backup summary, including any PDF report work, and mark the task status appropriately.
  action_instruction: >
    Use "send_message" to provide a short, clear summary:
    - Source root(s) {source_roots}.
    - Backup destination(s) {backup_destinations}.
    - Backup mode ({backup_mode}) and whether this was a dry-run or actual copy.
    - Whether report PDFs were created/updated (and where they are stored, if relevant).
    - Counts from the backup:
      - Total files processed.
      - Files copied.
      - Files skipped (already existed or excluded).
      - Files with errors.
    - Approximate total size of files copied (or would be copied).
    - Path to the backup log file {backup_log_path}.
    If it was dry-run only:
      - Clearly state that no files were actually copied, and ask if the user wants to run the backup for real.
    If the backup ran successfully to a reasonable standard:
      - Call "mark task completed" with a concise message summarizing key numbers and {backup_log_path}.
    If the user requested to stop before running the real backup:
      - Call "mark task cancel" with a brief reason (e.g., "user satisfied with dry-run only").
    If the script failed in a way that prevented meaningful backup:
      - Call "mark task error" with a short explanation and reference to {backup_log_path} if any partial log was produced.
