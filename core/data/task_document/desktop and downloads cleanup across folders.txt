name: Desktop and downloads cleanup across folders
description: Identify, group, and move cluttered files/folders/shortcuts from Desktop and Downloads into simple, organized folders based on file type, date, or project, using a single efficient script and minimal passes over the filesystem.

goal/outcome:
  - The specified Desktop and/or Downloads directories (and optionally a few related folders) are cleaned up so only actively used items remain at the top level.
  - Cluttered files, folders, and shortcuts are moved into clearly named subfolders according to the chosen organization rule(s) (by type, by date, and/or by project).
  - No files are deleted unless the user explicitly requests deletion; by default, all items are moved, not removed.
  - A single log file is created in the workspace recording, for each moved item: original path, new path, item type (file/folder/shortcut), and status.
  - The user receives a concise summary describing:
    - What areas were cleaned.
    - Which rules were used (by type/date/project).
    - How many items were moved and how many were left untouched.
    - Where the log file is stored.

inputs_params:
  - Required: Which folders to clean:
    - Desktop path (default suggestion: Windows user Desktop).
    - Downloads path (default suggestion: Windows user Downloads).
    - Optional additional folders (e.g., Documents\Temp, custom “Inbox” folder).
  - Required: Primary organization rule(s):
    - By type: group by extension or broad type (e.g., Documents, Images, Archives, Installers, Shortcuts, Folders).
    - By date: group by creation/modified date (e.g., year-month folders like 2025-11).
    - By project: group based on a simple keyword pattern in file/folder names (e.g., “ClientA_”, “ProjectX”).
  - Optional: Which items to treat as clutter:
    - Files only or files + folders + shortcuts.
    - Exclusions (e.g., pinned folders, specific filenames, or patterns to keep at root).
  - Optional: Target root for organized structure:
    - Same folder (subfolders under Desktop/Downloads).
    - A separate “Archive” or “Organized” folder path.
  - Optional: Date rule details (if using date-based):
    - Use created date or modified date.
    - Folder naming style (e.g., YYYY-MM, YYYY-MM-DD).
  - Optional: Project rules (if using project-based):
    - List of project keywords and their target subfolder names.
  - Optional: Dry-run flag (preview what would be moved without making changes).
  - Optional: Maximum number of items to move in one run (safety cap).

context:
  reasoning:
    - Keep the flow simple and efficient: confirm rules, scan and classify items, build target paths, move items once, and log everything.
    - Use CLI-based operations via a single “create and run python script” for scanning, classification, folder creation, and moving.
    - For each selected root (Desktop, Downloads, etc.), perform one traversal to:
      - Identify items at the top level (and optionally one level deeper, if the user requests).
      - Classify items based on the chosen rule(s) (type, date, project).
    - Build a straightforward target structure:
      - Type-based: subfolders like “Documents”, “Images”, “Archives”, “Installers”, “Shortcuts”, “Folders”.
      - Date-based: subfolders like “2025-11” (or similar per user preference).
      - Project-based: subfolders corresponding to specified project names/keywords.
    - When multiple rules are combined, apply them in a fixed order (e.g., project → type → date) that the user has agreed to, and keep it simple.
    - Use shutil.move (or os.rename) within the Python script to move items, and avoid multiple passes over the same data.
    - For each move, write a line to a single log file in the workspace.
    - Only create extra structures (like archives or deep nesting) if the user explicitly wants them.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The specified Desktop/Downloads (and any extra roots) contain fewer loose items, with clutter moved into clearly named subfolders.
    - No deletions happened unless explicitly requested; all moved items are accessible in their new locations.
    - Items that match user-defined exclusions remain in place.
    - A log file exists in the workspace mapping original paths to new paths with a status for each item (moved, skipped, error).
    - The user has been sent a short summary that includes:
      - Which roots were cleaned.
      - Rules used for organization.
      - Counts of items moved, skipped, and errored.
      - The path to the log file.
  avoid:
    - Deleting files or folders unless the user explicitly asks for deletion of specific patterns or age ranges.
    - Moving system-critical items, application install directories, or known OS shortcuts.
    - Recursively reorganizing deep folder trees when only top-level clutter cleanup was requested.
    - Over-engineered classification logic; stick to simple, transparent rules.
    - Using GUI mode for this task; CLI is sufficient.

steps:
  name: Confirm cleanup scope and rules
  description: Collect and confirm which folders to clean and how items should be organized (by type, date, project), as well as any exclusions and safety options.
  action_instruction: >
    Use "send_message" to summarize the needed inputs and current assumptions:
    - Desktop path and Downloads path, plus any other folders the user wants included.
    - The primary organization method: by type, by date, by project, or a simple combination (e.g., type + date).
    - Whether to organize only top-level items or also include one or more subfolder levels.
    - Which items should be treated as clutter (files only vs files + folders + shortcuts).
    - Exclusions: specific filenames, extensions, or folder names that must stay where they are.
    - Target root for organized subfolders (stay under Desktop/Downloads vs move into a dedicated “Organized” or “Archive” folder).
    - Whether this run should be a dry-run preview or apply moves immediately.
    - Any cap on number of items to move.
    Ask the user to confirm or correct. If something critical is still ambiguous (e.g., whether project rules or date-based grouping are needed), use "send_message" with a focused prompt. Once clarified, send a short "send_message" recapping the final rules so they are explicit.
  validation_instruction: >
    Ensure that:
    - At least one cleanup target folder is clearly defined (e.g., Desktop, Downloads).
    - At least one organization method is chosen and understandable.
    - Any exclusions are noted.
    - Dry-run vs real move is decided.
    If any of these is missing, call "send_message" to fill the gap before proceeding.

  name: Scan and classify items
  description: In a single pass, list items in the selected folders, decide which are clutter, and assign each clutter item to a target group based on the chosen rules.
  action_instruction: >
    Use "create and run python script" with a compact script that:
    - Accepts:
      - The list of root folders (Desktop, Downloads, etc.).
      - Rules for what counts as clutter vs items to keep.
      - The organization method (type/date/project).
      - Any include/exclude patterns.
      - An optional max_items limit.
    - For each root:
      - Verify it exists; if not, print a warning to stdout.
      - Enumerate items (preferably top-level only, unless deeper recursion was requested).
      - For each item:
        - Determine whether it is a file, folder, or shortcut (based on extension and attributes).
        - Check against exclusion rules; if excluded, mark as “keep” and skip classification.
        - If considered clutter:
          - If organizing by type: classify into broad type groups (documents, images, archives, installers, shortcuts, generic folders).
          - If organizing by date: determine the date key (created/modified) and derive a folder name like “YYYY-MM”.
          - If organizing by project: check for project keywords in name and assign to the matching project folder; if none match, fall back to a generic group (e.g., “Misc”).
      - Respect a max_items cap if provided by stopping classification once the limit is reached.
    - Compile a list of planned moves with fields:
      - original_path, group_label (type/date/project), and item_kind (file/folder/shortcut).
    - Print to stdout:
      - Number of roots scanned.
      - Number of clutter items identified.
      - A small sample of group assignments.
  validation_instruction: >
    Check the action’s status and stdout:
    - Ensure the script ran without unhandled exceptions.
    - Confirm that at least one root folder was found and scanned.
    - If zero clutter items were identified, send a brief "send_message" explaining that nothing matched the cleanup rules and ask if the user wants to adjust or stop.
    If there are clearly identified clutter items and the grouping looks reasonable, proceed.

  name: Create target folders and move items
  description: Create the necessary subfolders (type/date/project) under the chosen target root(s) and move clutter items there, logging all moves.
  action_instruction: >
    Use "create and run python script" with a script that:
    - Accepts:
      - The planned move list from the prior classification (can be re-computed or passed inline for simplicity).
      - The target root for organized content (e.g., within each source folder or under a central “Organized” folder).
      - The dry_run flag.
      - A log file path in the workspace (e.g., "desktop_downloads_cleanup_log_{timestamp}.csv").
    - For each planned move:
      - Construct a target folder path based on:
        - Group label (type/date/project).
        - Optionally preserve the originating root as a top-level grouping (e.g., Desktop/Documents vs Downloads/Documents) if rules specify.
      - Ensure the target folder exists (os.makedirs with exist_ok=True).
      - Build the full new path (target folder + original file/folder name).
      - If dry_run is false:
        - Use shutil.move (or os.rename) to move the item.
        - Catch and record any errors.
      - If dry_run is true:
        - Do not move; just record the intended move.
      - For each item, write a log line:
        - original_path, new_path (or planned_path for dry-run), item_kind, status ("moved", "skipped_excluded", "error"), and optional error message.
    - At the end, print to stdout:
      - Total clutter items processed.
      - Total moved.
      - Total skipped (exclusions).
      - Total errors.
      - The path to the log file.
  validation_instruction: >
    Review the action output:
    - Confirm the script completed without unhandled exceptions.
    - Confirm that a log file path is printed.
    - Note the counts of moved/skipped/errored items.
    If the script failed entirely, send a "send_message" explaining the error and decide whether to retry with a fixed script or "mark task error" if not reasonable to fix in this run.

  name: Overall validate cleanup results
  description: Use the log and summary output to verify the cleanup meets the definition_of_done without extra complex verification passes.
  action_instruction: >
    Based on the script’s stdout and the log file:
    - If this was a dry-run:
      - Use "send_message" to show the user a brief sample of planned moves and ask whether they want to re-run the move step without dry_run.
      - If they approve, rerun the previous step with dry_run=false and then re-check counts.
    - If moves were actually performed:
      - Optionally use "shell view" or a small "create and run python script" to inspect the log and confirm:
        - The number of log entries matches the number of processed clutter items reported.
        - Status values are only from a small, expected set ("moved", "skipped_excluded", "error").
      - Ensure that no unexpected statuses appear and error cases are relatively small or understandable (e.g., permission issues).
    If the results align with the definition_of_done (items moved, no deletions, log available), proceed to final reporting. If not, briefly explain any major discrepancies in a "send_message" and consider whether a limited retry is needed or "mark task error" is appropriate.

  name: Close task and report to user
  description: Summarize what was cleaned and how it was organized, provide the log location, and set the task status.
  action_instruction: >
    Use "send_message" to provide a concise summary:
    - Which root folders were cleaned (Desktop, Downloads, etc.).
    - The organization rule(s) applied (by type, by date, by project).
    - Whether the run was a dry-run or actual move.
    - Counts of clutter items identified, moved, skipped, and failed.
    - The path to the cleanup log file in the workspace.
    - Any notes on error cases (if present) and simple suggestions (e.g., items that might require manual review).
    If no items were moved, clearly state that and mention that the user can adjust rules if desired.
    Then:
    - If the cleanup completed to a reasonable standard, call "mark task completed" with a short message summarizing the success and log path.
    - If the user canceled partway, call "mark task cancel" with the stated reason.
    - If unrecoverable errors prevented meaningful cleanup, call "mark task error" with a brief explanation and the log path for reference.
