name: Automated submission of survey or feedback forms
description: Enter answers into surveys or feedback forms based on templates or provided responses, using the most efficient method available (HTTP automation when possible, GUI form filling only when necessary). Keep the workflow simple: confirm inputs, inspect form, submit responses, and validate.

goal/outcome:
  - The specified survey or feedback form at {form_url} (or equivalent application screen) is submitted with the user-provided answers.
  - If multiple submissions are requested (e.g., {number_of_submissions}), each submission follows the specified response template or variation rules.
  - The mapping between form fields and answers is explicit and applied consistently (e.g., {field_name} → {answer_text}).
  - Submissions succeed without obvious validation errors (e.g., required fields missing, server-side error pages).
  - A simple log file exists in the workspace listing timestamp, target form, field→value summary per submission, and status (success/error).
  - The user receives a concise summary of how many forms were submitted, which method was used (HTTP vs GUI), and where the log file is located.

inputs_params:
  - Required: Target form location:
    - Web form URL (e.g., {form_url}), or
    - Description of a non-web survey UI if applicable (e.g., a desktop app window).
  - Required: Response data:
    - A full set of answers for one complete submission, either:
      - As a template (e.g., {response_template_name} with field→value mapping), or
      - As explicit key/value pairs (e.g., {"question_1": "Yes", "question_2": "No"}).
  - Optional: Number of submissions:
    - Single submission, or
    - Multiple submissions using:
      - The same responses, or
      - A list of response sets, or
      - Simple variation rules (if provided).
  - Optional: HTTP context for web forms:
    - Required cookies or headers if known (e.g., {auth_cookie}, {api_key_header}).
    - Whether login/session steps are already handled.
  - Optional: Rate limiting:
    - Minimum delay between submissions (e.g., {delay_seconds} seconds).
    - Maximum total submissions allowed in this task.
  - Optional: Preferred method:
    - Prefer HTTP automation if feasible, or
    - Force GUI filling if the form is complex/interactive.
  - Optional: Dry-run:
    - Log the payloads or show a preview of field→value mapping without actually submitting.

context:
  reasoning:
    - Keep the process efficient:
      - First, confirm the form URL/context and response data.
      - Then inspect the form structure once to decide if HTTP-based submission is practical.
      - Fall back to GUI-based submission only when HTTP approaches are unreliable (e.g., heavy JavaScript, complex tokens).
    - For web forms:
      - Use "read web page from URL" to fetch the HTML for {form_url} and inspect inputs (names, IDs, method, action).
      - If the form appears simple (standard POST with recognizable input names and no obvious anti-automation features), use "send HTTP requests" from CLI to submit responses.
      - Use "create and run python script" to assemble payloads, handle cookies/headers, and loop over multiple submissions when needed.
    - For complex web or non-web forms:
      - Use "switch to GUI mode" to interact with the UI as needed (filling fields and submitting).
      - Optionally use "screenshot" if you need to capture state for debugging or verification.
    - Always log: each submission attempt should append a line to a simple log file using standard Python file I/O or "create text file" (and optionally "replace file str" if you need to append).
    - Keep validation minimal but meaningful: check HTTP status codes or resulting page content, or visible confirmation messages in GUI mode.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - For each requested submission:
      - A request was sent (HTTP) or the form was submitted (GUI) with the intended responses.
      - No known required field is left empty.
      - The server or UI acknowledges the submission with a success indicator (e.g., thank-you message, 2xx/3xx HTTP status).
    - The log file {log_file_path} exists and contains at least:
      - timestamp, form identifier (e.g., {form_url}), submission index, status, and a concise summary of field→value pairs.
    - The user receives a final message summarizing:
      - Method used (HTTP/GUI),
      - Number of successful and failed submissions,
      - Log file location.
  avoid:
    - Submitting forms without clear user-provided answers or templates.
    - Guessing answers or filling in sensitive fields (e.g., emails, personal IDs) without explicit instruction.
    - Overcomplicated workflows (multiple passes or heavy parsing) when simple HTTP or straightforward GUI filling works.
    - Excessive retries that might look abusive to the form provider.
    - Bypassing obvious anti-automation mechanisms (e.g., CAPTCHAs) beyond legitimate automation.

steps:
  name: Confirm form target and responses
  description: Collect and confirm the target form location and the exact answers or template to use, along with submission count and method preferences.
  action_instruction: >
    Use "send_message" to confirm:
    - The form target (e.g., {form_url} or a description of a local/app form).
    - Whether the form is public or requires an existing logged-in session.
    - The response data:
      - Either a template name plus field→value mapping, or explicit key/value pairs.
    - How many times to submit (e.g., once, or for each response set in a list).
    - Preferred method:
      - Try HTTP automation first if possible, or
      - Use GUI form filling directly.
    - Any constraints:
      - Rate limit between submissions,
      - Maximum total submissions,
      - Whether this should be a dry-run or actual submission.
    If any of these are missing or unclear (e.g., multiple templates but no mapping, unknown number of submissions),
    use "send_message" with a precise query such as:
    - "Please provide the form URL {form_url} you want me to submit."
    - "Please confirm the mapping between form fields and your answers (e.g., field name → answer)."
  validation_instruction: >
    Ensure that:
    - {form_url} or equivalent target description is known.
    - There is a complete answer set for at least one submission.
    - The number of submissions is either 1, {number_of_submissions}, or clearly tied to the length of a response list.
    - A method preference (HTTP vs GUI) is recorded or a simple default is chosen (e.g., HTTP first).
    If any critical piece is missing, repeat "send_message" once more; only proceed once the user has confirmed the final parameters.

  name: Inspect form and choose submission method
  description: For web forms, inspect the form HTML to decide whether HTTP-based submission is feasible; otherwise plan for GUI-based filling.
  action_instruction: >
    If the target is a web form at {form_url}:
      - Use "read web page from URL" with {form_url} to:
        - Retrieve the HTML,
        - Optionally extract main content, and
        - Get the final URL in case of redirects.
      - Quickly inspect the returned content (from the action output) to identify:
        - The <form> method (GET/POST),
        - The action URL (e.g., {post_url}),
        - Names/IDs of input fields that correspond to the user answers.
      - If the form appears standard (no obvious dynamic token fields or non-trivial JavaScript requirements),
        select HTTP mode:
        - Plan to use "send HTTP requests" or "create and run python script" to submit POST/GET requests with the correct payload.
      - If the form is clearly complex (heavily dynamic, multiple steps, visible CAPTCHAs, or missing key form markup in HTML snapshot),
        plan to use GUI mode instead:
        - Use "switch to GUI mode" later when actually filling the form.
    If the target is a non-web or clearly GUI-only form:
      - Decide upfront to use GUI mode and "switch to GUI mode" in the submission step.
  validation_instruction: >
    Based on the "read web page from URL" result:
    - Confirm that the form or its submit endpoint can be reasonably identified (method and action URL).
    - If that is not possible, or if the form looks dynamic/JS heavy, choose GUI mode.
    - If the form clearly supports simple HTTP POST/GET, choose HTTP mode.
    Record the chosen method in a short "send_message" so the decision is visible in the task history.

  name: Submit form responses (HTTP mode)
  description: When HTTP mode is chosen, submit one or multiple responses by sending requests directly to the form endpoint and logging results.
  action_instruction: >
    If HTTP mode is selected:
      - Use "create and run python script" to:
        - Define:
          - {post_url} (from the form action or {form_url} if appropriate),
          - headers (e.g., User-Agent, Referer, cookies from the user if needed),
          - the payload mapping form field names to the user-provided answers (e.g., {field_name}: {answer}).
        - For each submission index from 1 to {number_of_submissions} (or once if single):
          - Build the payload:
            - Merge the template with any per-submission variations if provided.
          - If dry-run is True:
            - Do not send HTTP; instead, log what would be sent.
          - If dry-run is False:
            - Use Python’s requests-like logic (install via pip if needed) or use multiple "send HTTP requests" calls inside this script’s logic:
              - Send a POST or GET to {post_url} with the payload and headers.
              - Record:
                - HTTP status code,
                - Final URL,
                - A short snippet of response text, if needed.
          - Append a log line (CSV or text) to {log_file_path} containing:
            - timestamp, submission_index, status ("sent", "error", or "dry_run"), HTTP status code, and a short field summary.
        - At the end, print to stdout:
          - Total submissions attempted,
          - Number successful (e.g., 2xx/3xx),
          - Number failed, and
          - The log file path {log_file_path}.
  validation_instruction: >
    After the script finishes:
    - Check the action status (must be success) and review stdout:
      - Ensure the reported number of submissions matches {number_of_submissions} or the inferred count.
      - Confirm that the log file path {log_file_path} is present.
      - Note any submissions with non-2xx/3xx codes as failures.
    If all submissions failed (e.g., 4xx/5xx), send a "send_message" to the user explaining this and suggest switching to GUI mode or checking authentication.

  name: Submit form responses (GUI mode)
  description: When GUI mode is chosen or HTTP submission fails, fill and submit the form using GUI interaction for one or more submissions.
  action_instruction: >
    If GUI mode is selected or needed:
      - Use "switch to GUI mode" to enable GUI control.
      - Ensure the browser or application showing {form_url} or the form screen is available (per environment capabilities).
      - For each submission index:
        - Navigate to the form page/screen if necessary.
        - Fill each field according to the field→value mapping from the user’s template or list:
          - For text fields, type the corresponding {answer_text}.
          - For radio buttons, checkboxes, dropdowns, select the option matching the provided answer.
        - Submit the form (e.g., press the Submit button).
        - Optionally use "screenshot" to capture the success/thank-you screen and store it at {screenshot_path} for reference.
        - Log the submission in {log_file_path} using a small "create and run python script" or by appending text via Python:
          - timestamp, submission_index, status ("submitted_gui" or "error_gui"), and short notes.
      - Keep GUI interaction minimal and deterministic; do not perform extra navigation beyond what is needed to reach and submit the form.
  validation_instruction: >
    Validate GUI submissions by:
    - Confirming visually (via the event stream and/or screenshot descriptions) that a success or thank-you message appears.
    - Checking that each intended submission produced at least one logged entry in {log_file_path}.
    If multiple submissions are requested and the UI clearly disallows duplicate submissions or throttles them, inform the user via "send_message" and stop further submissions to avoid issues.

  name: Overall validate submissions
  description: Check the log and high-level results against the definition_of_done, without unnecessary extra passes.
  action_instruction: >
    Use either "shell view" or a simple "create and run python script" to:
      - Read {log_file_path}.
      - Count lines by status (e.g., "sent", "submitted_gui", "error", "dry_run").
      - Confirm that:
        - The number of successful submissions ("sent" or "submitted_gui") matches the user’s expectations,
        - The total logged entries equals the total number of attempts.
      - If the task was dry-run only, ensure all statuses reflect "dry_run".
    If there are errors for a subset of submissions, note how many and prepare to mention them in the final summary. Only consider additional remedial actions (like retrying) if the user has asked for that explicitly.

  name: Close task and report to user
  description: Summarize what was done (or would have been done), surface the log location, and mark the task appropriately.
  action_instruction: >
    Use "send_message" to provide a concise summary:
    - Target form: {form_url} or equivalent description.
    - Method used: HTTP, GUI, or dry-run only.
    - Number of submissions attempted, number successful, number failed.
    - Whether any steps fell back from HTTP to GUI.
    - Location of the log file {log_file_path}, and (if created) any screenshot path {screenshot_path}.
    - Any notable errors or required follow-up (e.g., authentication issues, server errors, duplicate-submission restrictions).
    If the requested submissions were successfully completed according to the definition_of_done:
      - Call "mark task completed" with a short message capturing method, count, and log location.
    If the user decided to stop after dry-run or canceled mid-way:
      - Call "mark task cancel" with a brief reason.
    If systemic errors prevented meaningful submissions (e.g., persistent server failures, required login unavailable):
      - Call "mark task error" with a short description and a pointer to {log_file_path} so the user can inspect the details.
