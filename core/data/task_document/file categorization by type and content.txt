name: File categorization by type and content
description: Scan one or more folders and organize files into category folders (e.g., Documents, Images, Videos, Archives) or simple project-based folders, using file type and basic content/filename cues. Use an efficient CLI-based script to plan and apply moves, and keep a single log of actions.

goal/outcome:
  - Files under the specified root folder(s) are organized into clearly named category or project folders according to the user’s rules.
  - Category folders (e.g., Documents, Images, Videos, Audio, Archives, Other) or project folders are created once and reused.
  - Files are moved, not duplicated, unless the user explicitly asks for copies.
  - No unintended files or folders outside the specified roots are touched.
  - Name collisions in destination folders are handled predictably (e.g., append a counter) without silent overwrites.
  - A single log file in the workspace records, for each processed file: original path, destination path, category/project, and status.
  - The user receives a short summary: roots processed, categorization scheme used, counts per category, skipped files, and log location.

inputs_params:
  - Required: One or more root directory paths to scan and organize.
  - Required: Target organization scheme:
    - Type-based categories (e.g., Documents, Images, Videos, Audio, Archives, Other), OR
    - Project-based folders (e.g., “ProjectA”, “ProjectB”) with simple assignment rules (by path segment or filename keywords).
  - Required for type-based mode: Mapping from file extensions to categories (can be defaulted if the user agrees, e.g., .pdf/.docx/.txt → Documents; .jpg/.png → Images; .mp4/.mov → Videos; .zip/.rar/.7z → Archives).
  - Optional: Base destination directory:
    - Same as each root (create category folders inside each root), or
    - A single central “organized” folder where category/project folders are created.
  - Optional: Whether to include subfolders (recursive: true/false).
  - Optional: Include/exclude rules:
    - Include extensions or simple name patterns.
    - Exclude extensions, folders (e.g., .git, node_modules), or hidden/system files.
  - Optional: Collision handling strategy when a file with the same name already exists in the destination:
    - Append counter (default).
    - Skip.
  - Optional: Dry-run flag to preview the plan (no moves).
  - Optional: Maximum number of files to process (safety cap).

context:
  reasoning:
    - Keep the flow linear and efficient: confirm rules → scan and categorize → move files in one pass → log and summarize.
    - Use "create and run python script" as the main workhorse for scanning, categorization, and moving files; avoid GUI and complex multi-phase plans.
    - Categorize primarily by file extension, with optional simple “content” rules such as:
      - Path/filename keywords for project folders.
      - (Optional, if user insists) basic inspection of file text for keywords using lightweight reads; avoid heavy per-file parsing by default.
    - Create category or project folders only when needed (lazy creation) to minimize extra operations.
    - Apply moves using standard filesystem operations (e.g., shutil.move in Python), handling collisions via a simple rule (append counter or skip).
    - Maintain a single log file covering planning and execution status so the user can review or undo manually if needed.
    - Run a brief, final validation based on counts and the log; do not introduce extra passes unless something looks clearly wrong.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The selected root folder(s) have been scanned and files within them have been processed according to the agreed categorization rules.
    - Each processed file has either been moved into the correct category/project folder or skipped with a recorded reason (e.g., excluded by rule, collision, error).
    - No files outside the specified root paths have been moved.
    - No file in the destination was silently overwritten.
    - A log file exists in the workspace that records at least: original_path, destination_path, category/project, status, and (if applicable) a short error note.
    - The user has received a concise summary describing categories used, counts per category, skipped/error counts, and the log path.
  avoid:
    - Deep, expensive content analysis for every file (e.g., parsing all PDFs/Word docs) unless explicitly requested.
    - Moving system, hidden, or obviously unrelated folders unless the user explicitly includes them.
    - Multiple redundant scans; one scan with categorization is enough.
    - Using GUI mode; CLI is sufficient.
    - Complicated backup/restore workflows by default—logs are enough for manual undo unless the user asks for backups.

steps:
  name: Confirm scope and categorization rules
  description: Collect and confirm the root paths, whether the user wants type-based or project-based categorization, and the basic rules for where each file type should go.
  action_instruction: >
    Use "send_message" to state the current understanding and request missing details:
    - Ask for: root directory path(s) to scan.
    - Ask the user to choose: type-based categories (Documents/Images/Videos/Archives/etc.) or project-based folders.
    - If type-based:
      - Propose a simple default extension-to-category mapping and ask if it is acceptable (e.g., .pdf/.docx/.txt → Documents; .jpg/.png → Images; .mp4/.mov → Videos; .zip/.rar/.7z → Archives; everything else → Other).
    - If project-based:
      - Ask for project folder names and simple assignment rules (by path segment or filename keywords).
    - Ask whether subfolders should be included (recursive).
    - Ask whether there is a base destination directory or if category/project folders should be created inside each root.
    - Ask if any file types or folders should be excluded (e.g., hidden files, specific extensions, or directories).
    - Ask for collision handling preference (append counter by default, or skip).
    - Ask if they want a dry-run preview (log only) before actual moves.
    Once the user responds, send a brief "send_message" summarizing the final rules so they are explicit in the task history.
  validation_instruction: >
    Ensure that:
    - At least one root directory path is provided.
    - A categorization mode is chosen (type-based or project-based).
    - For type-based: there is a clear extension mapping (either the default accepted or a user-provided variant).
    - For project-based: there is at least one project folder name and a simple rule for assignment.
    - Recursion and collision strategy are decided (default collision: append counter).
    If any of these are missing or ambiguous, use "send_message" with a focused prompt and only proceed once the user has clearly confirmed.

  name: Scan and categorize files
  description: Traverse the specified root folder(s) once, apply the categorization rules to each file, and prepare a plan (including optional dry-run mapping) in a single script.
  action_instruction: >
    Use "create and run python script" with a compact script that:
    - Accepts as constants or configuration inside the code:
      - Root paths.
      - Recursion flag.
      - Include/exclude rules (extensions or simple patterns).
      - Categorization scheme (type-based mapping or project-based keyword rules).
      - Base destination directory behavior.
      - Collision strategy.
      - Dry_run flag.
      - Path for a log file (e.g., "file_categorization_log_{timestamp}.csv") in the workspace.
    - For each root:
      - Verify that the directory exists; if not, record a line in the log with status "root_not_found" and continue with others.
      - Walk the directory tree using os.walk (or a non-recursive variant if recursion is false).
      - Skip excluded directories and hidden/system entries according to the rules.
      - For each file:
        - If excluded by rule, record in the log with status "skipped_excluded" and continue.
        - Determine its category/project:
          - For type-based: look up by extension with a default category if not explicitly mapped.
          - For project-based: match by path segment or filename keyword, with a default fallback project/category if nothing matches.
        - Compute the destination folder path (base destination + category/project folder).
        - Compute the destination file path inside that folder (same filename initially).
        - If a file with that name already exists in the destination:
          - If collision strategy is "append counter", append "_1", "_2", etc. before the extension until a free name is found.
          - If "skip", mark status "skipped_collision" and do not move.
        - If dry_run is true:
          - Do not move the file; just record a log line with original_path, planned_destination_path, category, status "planned".
        - If dry_run is false:
          - Create the destination folder if needed.
          - Move the file (e.g., shutil.move) inside a try/except block.
          - Record status "moved" or "error" with a short error message if an exception occurs.
    - At the end, print to stdout a short summary:
      - Total files seen.
      - Total files moved (if not dry-run).
      - Total planned (if dry-run).
      - Skipped (by exclusion or collision).
      - Errors.
      - The log file path.
  validation_instruction: >
    Check the script’s action output:
    - Status should indicate success (no unhandled exception).
    - Ensure stdout includes a summary and a log file path.
    - If zero files were seen or all were skipped, send a short "send_message" explaining that nothing was moved and why (e.g., filters too tight), and ask if the user wants to adjust rules or finish.
    If the script failed with a clear coding or permission error, briefly explain via "send_message" and decide whether to retry with a corrected script or "mark task error".

  name: Review and optionally re-run without dry-run
  description: If a dry-run was requested, let the user review the plan, then optionally repeat the categorization with moves enabled.
  action_instruction: >
    If dry_run was true:
      - Use "send_message" to:
        - Inform the user that a dry-run mapping has been created.
        - Provide the log file path.
        - Include a small sample of the summary from stdout (e.g., count of planned moves per category).
        - Ask the user explicitly whether to proceed with the actual moves using the same rules.
      - If the user approves, repeat the previous step ("Scan and categorize files") with dry_run set to false, using the same rules, and overwrite the log file name or create a new one with a different suffix.
      - If the user declines, end the task after summarizing that no files were moved.
    If dry_run was false from the start, skip this step and proceed directly to final validation and reporting.
  validation_instruction: >
    If a real move run was executed after a dry-run:
      - Confirm from the latest script output that moves actually occurred (non-zero "moved" count).
      - Ensure the latest log file path is clear and will be referenced in the final message.
    If the user decided to stop after the dry-run, ensure it is clearly noted in a "send_message" that the task ended with no file changes.

  name: Final check against definition_of_done
  description: Use the script’s summary and log to verify that the operation meets the agreed criteria without extra scanning.
  action_instruction: >
    Perform a lightweight final check:
    - From the last script run (the one that moved files, if any), read the summary in stdout:
      - Note totals: seen, moved, skipped (excluded/collision), errors.
    - Optionally use "create and run python script" or "shell view" to:
      - Open the log file.
      - Count how many entries have each status ("moved", "planned", "skipped_excluded", "skipped_collision", "error", etc.).
    - Verify that:
      - The counts in the log roughly match the counts printed in stdout.
      - There are no unexpected statuses.
      - For any non-zero error count, you are ready to mention this and typical reasons in the final summary (no need to re-run unless the user later asks).
    If these checks look consistent, treat the definition_of_done as satisfied from a practical standpoint and move to reporting.
  validation_instruction: >
    Confirm that:
    - A log file exists at the mentioned path.
    - The log has entries for each processed file (at least for files that matched filters).
    - No indication appears that files outside the specified roots were touched (paths in the log should all start under the roots or destination base).
    If these conditions are met, you can safely finalize; otherwise, briefly explain any discrepancy and, if it cannot be easily fixed, prepare to "mark task error" with clear details.

  name: Close task and report to user
  description: Summarize the categorization results, share the log location, and finalize the task status.
  action_instruction: >
    Use "send_message" to deliver a concise final summary:
    - State the task name and that categorization is complete (or that it was a dry-run only).
    - List:
      - Root directory path(s) processed.
      - Categorization mode (type-based or project-based).
      - The main mapping rules used (categories or projects and key extension/keyword mappings).
      - Whether it was a dry-run or actual moves.
      - Counts: total files seen, moved, skipped (by exclusion and collision), and errors.
      - The path to the log file in the workspace.
    - If the user only ran a dry-run, clearly say that no files were moved and they can re-run later with the same rules.
    Then:
    - If the operation meets the agreed rules and the user has not canceled:
      - Call "mark task completed" with a short message summarizing success and pointing to the log.
    - If the user canceled (e.g., after dry-run or mid-discussion):
      - Call "mark task cancel" with the reason.
    - If unrecoverable errors prevented proper categorization:
      - Call "mark task error" with a short explanation and the log path so the user can inspect what happened.
