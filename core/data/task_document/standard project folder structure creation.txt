name: Standard project folder structure creation
description: Create or normalize a consistent folder structure under a project root and move existing files into appropriate subfolders based on simple, user-defined rules.

goal/outcome:
  - A standard project folder structure exists under {project_root}, with all required subfolders created (e.g., {docs}, {src}, {assets}, {tests}, {build}, {archive}, etc. as defined by the user).
  - Existing files and folders within {project_root} are moved into appropriate subfolders according to simple, agreed rules (for example, by file extension or name pattern).
  - No files are deleted or silently overwritten during the process.
  - A simple log file at {log_file_path} records what was moved from where to where, and which items were skipped.
  - The user receives a concise summary of the structure created, how many files were moved, and where the log file is stored.

inputs_params:
  - Required: {project_root} – the absolute path to the project root directory.
  - Required: Standard folder structure definition, either:
    - A named template (e.g., {project_type}: "software", "data", "design"), or
    - An explicit list of subfolders to create under {project_root} (e.g., ["docs", "src", "assets", "tests", "build", "archive"]).
  - Required: Simple classification rules for existing files, for example:
    - Extension-based (e.g., .py → src, .md → docs, .png/.jpg → assets).
    - Optional name-based hints (e.g., filenames containing "test" → tests).
  - Optional: Rules for handling existing top-level folders (e.g., whether to merge or move them into new structure).
  - Optional: Folder for uncategorized items (e.g., {project_root}/misc or {project_root}/archive/uncategorized).
  - Optional: Dry-run flag (only compute and log what would be moved, without performing moves).
  - Optional: Maximum number of moves to perform in one run (safety cap).

context:
  reasoning:
    - Keep the workflow simple: confirm structure and rules, create missing subfolders, classify existing items, move files in one or two efficient passes, and log the results.
    - Prefer CLI-based automation using "create and run python script" to create folders, scan {project_root}, classify files, and move them.
    - Use "create folder" only if a simple single-folder creation is needed; otherwise let the Python script create all required subfolders.
    - Classify existing files using straightforward rules (mainly by extension and simple name patterns) to avoid complex heuristics.
    - When moving files, avoid overwrites by checking if the target path exists; if it does, append a minimal suffix (e.g., "_1") to the filename.
    - Avoid deleting or renaming folders unless explicitly requested; focus on creating structure and moving files.
    - Log all moves and skips in a single text/CSV log at {log_file_path} for transparency.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - All subfolders specified in the standard structure exist under {project_root}.
    - Each processed file either:
      - Has been moved into a subfolder that matches the classification rules, or
      - Has been skipped with a reason logged (for example, “no rule” or “target exists”).
    - No file outside {project_root} was affected.
    - No file overwrites occurred silently.
    - A log file {log_file_path} exists with at least: original_path, new_path (or same), and status.
    - The user has received a short summary message describing the structure created, the number of files moved, and where the log file is stored.
  avoid:
    - Guessing complex classification rules beyond simple extension or simple substring matches.
    - Deleting files or folders as part of normalization.
    - Moving or renaming items outside {project_root}.
    - Using GUI mode or extra passes when one or two CLI-based scripts are sufficient.
    - Overcomplicating with backups or multi-phase workflows unless the user explicitly asks.

steps:
  name: Confirm project root and structure
  description: Ensure that the project root, standard folder structure, and classification rules are clearly defined and agreed with the user.
  action_instruction: >
    Use the "send_message" action to restate the needed parameters and the current understanding:
    - {project_root}: the main directory where the project lives.
    - Standard folder structure: either a named template {project_type} (e.g., "software", "data") or an explicit list
      of subfolders under {project_root} (e.g., ["docs", "src", "assets", "tests", "build", "archive"]).
    - Simple classification rules for existing files (for example:
      - .py, .js, .ts → src
      - .ipynb, .csv → data
      - .md, .txt → docs
      - .png, .jpg, .svg → assets
      - "*test*" in filename → tests).
    - Destination for uncategorized files (e.g., {project_root}/misc).
    - Whether a dry-run is desired (only log moves without changing the file system).
    Ask the user to confirm or correct these values. If any critical part is missing or ambiguous (for example, the exact
    subfolder list or how to handle uncategorized files), use "send_message" with a focused question such as
    "Please confirm the subfolder list under {project_root}" or "Where should uncategorized files go?".
    Once everything is clear, send a short "send_message" summarizing:
    - {project_root}
    - Final subfolder list
    - Key classification rules
    - Dry-run vs actual moves.
  validation_instruction: >
    Verify that:
    - {project_root} is specified.
    - A non-empty list of subfolders or a recognizable template {project_type} is provided.
    - At least one concrete classification rule is defined (for example, mapping extensions to subfolders).
    - Destination for uncategorized files is either defined or explicitly stated as “leave in place”.
    - Dry-run vs actual move has been decided.
    If any of these are missing, call "send_message" again and do not proceed until the user has confirmed them.

  name: Create standard folder structure
  description: Create the standard subfolders under {project_root} if they do not already exist.
  action_instruction: >
    Use "create and run python script" with a small script that:
    - Accepts:
      - {project_root}
      - {subfolder_list} (e.g., ["docs", "src", "assets", "tests", "build", "archive", "misc"])
    - For each subfolder name in {subfolder_list}:
      - Build the full path: {project_root}/{subfolder_name}.
      - Use os.makedirs(full_path, exist_ok=True) to ensure the folder exists.
    - Print to stdout a summary of which folders were created vs already existed.
    This keeps folder creation in a single efficient pass without multiple separate actions.
  validation_instruction: >
    Check the action output:
    - The script must finish without unhandled exceptions.
    - Confirm that each intended subfolder appears in the summary as “created” or “already exists”.
    If there are errors (for example, permissions or invalid path), inform the user via "send_message" and either:
    - Adjust {project_root} or {subfolder_list} as per user input, then retry, or
    - If the root is unusable, use "mark task error" with a brief explanation.

  name: Classify and move existing files
  description: Scan {project_root}, classify existing files according to the agreed rules, and move them into appropriate subfolders in a single efficient pass (or simulate if dry-run).
  action_instruction: >
    Use "create and run python script" with a script that:
    - Accepts:
      - {project_root}
      - {subfolder_list}
      - {classification_rules} (extension → subfolder, optional name pattern → subfolder).
      - {uncategorized_folder} (e.g., "misc") or a flag indicating "leave in place".
      - {dry_run} (True/False).
      - {log_file_path} for a CSV or simple text log in the workspace (e.g., "project_structure_moves_{date_time}.csv").
    - Walk {project_root} using os.walk:
      - Skip the workspace or log location if it lives under {project_root} and should not be moved.
      - For each file encountered:
        - Determine its relative path from {project_root} and its extension.
        - Decide the target subfolder:
          - First match by extension in {classification_rules}.
          - Optionally check simple name patterns (e.g., "*test*").
          - If no rule matches:
            - If {uncategorized_folder} is defined, target that subfolder.
            - Otherwise, mark as "no_rule" and leave it in place.
        - If a target subfolder exists and is different from the current folder:
          - Build the new path: {project_root}/{target_subfolder}/{file_name}.
          - If the new path already exists, append a simple suffix such as "_1" before the extension until a free name is found.
          - If {dry_run} is True:
            - Do not move; set status to "would_move".
          - If {dry_run} is False:
            - Use shutil.move(old_path, new_path) inside a try/except.
            - Set status to "moved" on success or "error" with the exception message on failure.
        - If no move is needed (same folder or no rule), set status appropriately ("unchanged" or "no_rule").
        - Append a log line with:
          - original_path, new_path (or original_path if unchanged), status, and error_message (if any).
    - When finished:
      - Write the log to {log_file_path}.
      - Print a short summary to stdout:
        - Total files seen.
        - Files moved.
        - Files unchanged/no_rule.
        - Errors encountered.
        - {log_file_path}.
  validation_instruction: >
    Review the script output:
    - Confirm the script completed successfully.
    - Note the counts of moved, unchanged/no_rule, and error entries.
    - Ensure that {log_file_path} is reported.
    If the script failed completely (for example, due to a path error), inform the user with a brief "send_message" and either
    retry after correcting the issue or use "mark task error" if it is not fixable.
    For heavy error counts, mention this in the final summary so the user can review the log.

  name: Validate project structure and moves
  description: Perform a light final check that the structure exists and the moves behaved as expected based on the log and summary.
  action_instruction: >
    Perform minimal validation using the log and simple checks:
    - Optionally use "create and run python script" or "shell view" to:
      - Open {log_file_path}.
      - Count how many lines have status "moved", "would_move", "no_rule", "unchanged", or "error".
    - Confirm:
      - That at least some files were classified and moved if the user expected reorganization.
      - That there are no obvious anomalies (for example, all statuses are from the expected set).
    - Optionally, use "list folder" for a couple of key subfolders (e.g., {project_root}/src, {project_root}/docs) to confirm they contain expected file types.
    No full rescan is necessary unless the counts or user feedback suggest something is wrong.
  validation_instruction: >
    Check that:
    - The log appears to cover all processed files (counts are consistent with the script summary).
    - Key subfolders (e.g., src, docs, assets) exist and are not empty if files of those types existed originally.
    - Any errors recorded in the log are noted for the final report.
    If something looks clearly incorrect or incomplete, inform the user via "send_message" and, if they request,
    rerun the classification/move step or stop and "mark task error" with an explanation.

  name: Close task and report to user
  description: Summarize the new project structure and file moves, provide the log location, and set the final task status.
  action_instruction: >
    Use "send_message" to provide a concise summary:
    - {project_root} and a short description of the standard structure created.
    - Whether this was a dry-run or actual move.
    - Count of total files scanned, files moved, unchanged/no_rule files, and error cases (if any).
    - Example mappings (1–3 sample moves) so the user sees how files were grouped (e.g., "old/path/file.py → src/file.py").
    - The path to {log_file_path} so the user can review details.
    If {dry_run} is True and the user wants to stop at the preview, clearly state that no files were changed.
    If the reorganization has been applied successfully and meets the user’s expectations:
      - Call "mark task completed" with a short message summarizing:
        - Project root
        - Structure created
        - Number of files moved and log path.
    If the user cancels during the process (for example, after seeing the log in a dry-run):
      - Call "mark task cancel" with a brief reason.
    If significant errors prevented meaningful reorganization:
      - Call "mark task error" with a short explanation and log path so the user can inspect what was attempted.
