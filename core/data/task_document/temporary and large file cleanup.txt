name: Temporary and large file cleanup
description: Find temporary, cache, and large files in one or more directories and either delete them or move them to a cleanup folder to free up disk space. Use a small number of efficient CLI-based actions, with simple logging and minimal assumptions.

goal/outcome:
  - Identify candidate files under the specified root directory/ies that match:
    - Temporary or cache-like patterns (e.g., *.tmp, *.log, typical cache folders) and/or
    - Size threshold (e.g., larger than N MB/GB) and/or
    - Optional age threshold (e.g., older than N days).
  - Perform the cleanup according to the user’s choice:
    - Delete matching files, or
    - Move them to a specified cleanup/archive folder.
  - Preserve non-target files and any explicitly excluded paths or patterns.
  - Avoid silently overwriting when moving; handle move collisions simply (e.g., append a counter).
  - Create a single log file in the workspace listing each file processed, what happened to it (deleted/moved/skipped), and any errors.
  - Send the user a brief summary of how much space was potentially freed, how many files were affected, and where the log file is located.

inputs_params:
  - Required: One or more root directory paths where cleanup should be applied.
  - Required: Cleanup mode:
    - delete: remove matching files.
    - move: relocate matching files to a specified cleanup folder.
  - Required (for move mode): Destination cleanup folder path (existing or to be created).
  - Required: Size threshold for “large” files, e.g., in MB or GB (e.g., 100 MB+).
  - Optional: Age threshold (e.g., only clean files older than N days).
  - Optional: Temporary/cache matching rules:
    - Extensions: e.g., .tmp, .log, .bak.
    - Name patterns: e.g., *cache*, *temp*.
    - Known subdirectory names to target, if user provides them (e.g., specific cache folders).
  - Optional: Exclude rules:
    - Paths to skip (e.g., specific program folders).
    - Extensions or file patterns to protect.
  - Optional: Dry-run flag (discover and log, but do not modify anything).
  - Optional: Safety cap: maximum number of files to affect or maximum total size to process before asking the user.

context:
  reasoning:
    - Keep the flow short and efficient: confirm parameters, scan once, decide candidates, then apply delete/move actions in one script, logging as you go.
    - Prefer one or two calls to "create and run python script" rather than many smaller actions.
    - Use a single traversal (os.walk) over the provided roots, applying filters for size, extension, name patterns, and age where specified.
    - The same script that finds candidates can also perform the cleanup in one pass (especially when not in dry-run mode), to avoid re-scanning.
    - Maintain a simple log file (CSV or text) in the workspace listing: file_path, size_bytes, action (deleted/moved/skipped), and error if any.
    - Use a dry-run only if the user requests it or seems uncertain about the scope.
    - Avoid touching system-critical locations or user-protected paths if they are explicitly excluded.
    - Rely on basic Python standard library (os, shutil, datetime) via "create and run python script"; no need for GUI mode.
  deadline: {time_left} left until deadline {deadline}
  definition_of_done(check during final validation step):
    - The task has either:
      - Produced a list of candidate files and a dry-run log, or
      - Actually deleted/moved files according to the confirmed parameters.
    - No files outside the specified roots (and not matching rules) were modified.
    - No file was overwritten during move operations without following the chosen collision behavior (e.g., append counter).
    - A log file exists in the workspace with per-file action/status and is referenced in the final summary.
    - The final message to the user includes:
      - Roots processed.
      - Cleanup mode (delete/move).
      - Basic rules (size threshold, optional age, patterns).
      - Counts and approximate total size of cleaned candidates.
      - Path to the log file.
  avoid:
    - Running unnecessary extra scans or complex backup/restore flows unless explicitly requested.
    - Using GUI mode; CLI and scripts are sufficient.
    - Deleting or moving files without user-confirmed rules.
    - Scanning the entire drive without at least a basic size or path filter.
    - Silently ignoring errors; they should be recorded in the log.

steps:
  name: Confirm cleanup scope and policy
  description: Collect and confirm what to clean, where to clean, and what to do with matching files.
  action_instruction: >
    Use the "send_message" action to restate and confirm:
    - The root directory path(s) to scan.
    - Cleanup mode:
      - delete (remove files), or
      - move (relocate to a cleanup folder).
    - If move mode: the destination folder path (ask whether to create it if it does not exist).
    - Size threshold for “large” files (e.g., "files >= 100 MB").
    - Optional age threshold (e.g., "only files older than 30 days") if the user cares.
    - Temporary/cache matching rules (extensions such as .tmp, .log; name patterns containing "temp" or "cache" if user wants).
    - Any paths or patterns to exclude.
    - Whether they want a dry-run (no changes, just log) or immediate actual cleanup.
    - Any safety cap (max files or total size).
    Ask the user to confirm or adjust these. If something critical is unclear (e.g., mode, threshold, or destination),
    use "send_message" with a focused question. Once clarified, send a short "send_message" summarizing the final agreed parameters.
  validation_instruction: >
    Ensure that:
    - At least one root directory path string is provided.
    - Cleanup mode is explicitly chosen (delete or move).
    - Size threshold is set to a reasonable positive value.
    - If move mode is chosen, a destination folder path is provided.
    - Dry-run vs actual cleanup is decided.
    If any of these are missing or conflicting, use "send_message" again. Proceed only when the user has clearly confirmed the parameters.

  name: Scan for candidate files and optionally perform dry-run
  description: Traverse the directories once to find files that match the cleanup criteria, optionally logging a dry-run without modifying anything.
  action_instruction: >
    Use "create and run python script" with a single script that:
    - Accepts:
      - root_paths (list),
      - mode ("delete" or "move"),
      - dest_dir (for move mode),
      - size_threshold_bytes,
      - optional age_threshold_days,
      - include patterns (extensions / substring matches),
      - exclude patterns/paths,
      - dry_run (True/False),
      - safety caps (max_files, max_total_bytes) if provided,
      - a log file path in the workspace, e.g., "cleanup_log_{timestamp}.csv".
    - For each root path:
      - Check that it exists and is a directory; if not, record an info message and continue to the next root.
    - Walk each existing root using os.walk:
      - Optionally skip excluded paths early (e.g., if folder path contains an excluded substring).
      - For each file:
        - Compute its size (os.path.getsize) and optionally age (based on modification time).
        - Apply:
          - size filter (size >= threshold),
          - age filter (if used),
          - include patterns, and
          - exclude patterns.
        - If the file matches all filters, treat it as a candidate.
        - Track the accumulated count and total size; if safety caps are exceeded, stop collecting further candidates and note this in the log/summary.
    - For each candidate:
      - Determine the action:
        - If dry_run is True: action = "would_delete" or "would_move".
        - If dry_run is False:
          - If mode == "delete": attempt os.remove(path).
          - If mode == "move":
            - Ensure dest_dir exists (os.makedirs(dest_dir, exist_ok=True)).
            - Build a destination path under dest_dir, preserving relative structure if desired or using just the filename.
            - If the destination file exists, append a simple suffix (e.g., "_1", "_2") to avoid overwrites.
            - Use shutil.move to move the file.
          - Set status = "deleted", "moved", or "error" based on the outcome.
      - Append a log line with:
        - file_path, size_bytes, action/status, error_message (empty if none).
    - At the end:
      - Write the log to the specified log file (CSV or simple delimited text).
      - Print to stdout:
        - Total roots visited.
        - Total candidate files.
        - Total size of candidates (bytes or converted to MB/GB).
        - Counts of actions (deleted/moved/would_delete/would_move/skipped_on_error).
        - The log file path.
  validation_instruction: >
    Check the script output from "create and run python script":
    - The status must indicate success (no unhandled exception).
    - The script must report the number of candidates and the log file path.
    - If it reports zero candidates, send a brief "send_message" to the user explaining that no files matched the filters and
      ask if they want to adjust thresholds or stop.
    - If a safety cap was reached, ensure this is mentioned in the summary to the user.
    For dry-run:
      - Confirm that only "would_delete" or "would_move" appear in the log, with no actual file operations performed.
    For actual cleanup:
      - Confirm that "deleted" or "moved" statuses are present for candidates.

  name: (Optional) Execute actual cleanup after dry-run
  description: If the user requested a dry-run first, optionally rerun the script to perform the real cleanup using the same parameters.
  action_instruction: >
    If dry_run was True:
      - Use "send_message" to:
        - Tell the user that the dry-run has completed.
        - Provide a short summary: candidate count, approximate total size, and the log file path.
        - Ask whether to proceed with actual cleanup using the same rules.
      - If the user confirms:
        - Call "create and run python script" again with dry_run set to False and the same parameters
          (root paths, mode, thresholds, patterns, destination).
        - This second run can re-scan and clean in one pass; no need for extra complexity.
      - If the user declines:
        - Note that no files were touched and proceed to final reporting.
  validation_instruction: >
    For the second run (if performed):
    - Validate as in the previous step: successful script status, non-zero affected files if expected, and a log file path.
    - If the user declines to proceed, no further validation is needed other than stating clearly that it remained a dry-run.

  name: Overall validate cleanup
  description: Check results against the definition_of_done using the script summary and log file; keep validation minimal but sufficient.
  action_instruction: >
    Use the data from the script’s stdout and the log file to perform a simple final check:
    - Use "shell view" or a small "create and run python script" to:
      - Count the number of lines in the log (excluding header, if any).
      - Count how many lines have statuses "deleted" or "moved".
      - Count how many have "error" or similar.
    - Verify:
      - That the total processed count matches what the script reported.
      - That there is at least a reasonable number of affected files if the user expected cleanup.
      - That errors, if any, are recorded but do not undermine the entire operation.
    No extra directory rescans are needed unless something looks obviously wrong in the counts or errors.
  # No separate validation_instruction needed beyond the simple checks above.

  name: Close task and report to user
  description: Summarize what was done (or would have been done in dry-run), expose key log details, and mark task status.
  action_instruction: >
    Use "send_message" to provide a short, clear summary:
    - Root directories scanned.
    - Cleanup mode (delete/move).
    - Size (and age, if used) thresholds.
    - Whether it was dry-run only, or actual cleanup.
    - Approximate total size of candidate files and how many were deleted/moved vs. skipped or errored.
    - The path to the log file in the workspace.
    - If move mode was used, the destination cleanup folder path.
    If operation was purely dry-run at the user's request:
      - Clarify that no files were changed.
    For a successful actual cleanup:
      - Call "mark task completed" with a concise message summarizing the main numbers and log location.
    If the user canceled instead of proceeding with actual cleanup:
      - Call "mark task cancel" with a short reason.
    If the script repeatedly failed or could not access key directories and meaningful cleanup was not possible:
      - Call "mark task error" with a brief explanation and log path so the user can inspect partial results.
