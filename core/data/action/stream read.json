{
  "_id": { "$oid": "68b6ad213aa5a3e9d9026b9d" },
  "name": "stream read",
  "description": "Reads a text file and returns a paginated slice of lines and segments, similar to `sed -n 'start,endp'` but safe for very long lines.",
  "type": "atomic",
  "execution_mode": "sandboxed",
  "mode": "CLI",
  "platforms": ["windows", "linux", "darwin"],
"input_schema": {
  "input_file": {
    "type": "string",
    "example": "/path/to/file.txt",
    "description": "Absolute or relative path to the input text file to read. The file must already exist on disk and be readable as UTF-8 text (binary files are not supported)."
  },
  "start_line": {
    "type": "integer",
    "example": 1,
    "description": "1-based start line number (inclusive) for the portion of the file you want to read. If start_line is less than 1, it will be treated as 1. If start_line is larger than the total number of lines in the file, it will be clamped to the last line. Only lines in the range [start_line, end_line] are considered when building segments.",
    "default": 1
  },
  "end_line": {
    "type": "integer",
    "example": 200,
    "description": "1-based end line number (inclusive) for the portion of the file you want to read. If end_line is less than 1, it will be treated as 1. If end_line is larger than the total number of lines, it will be clamped to the last line. If end_line < start_line, the two values are swapped internally so the effective range is always from the smaller to the larger line number. Only lines in the final [start_line, end_line] range are used to build segments.",
    "default": 200
  },
  "max_segment_chars": {
    "type": "integer",
    "example": 2000,
    "description": "Maximum number of characters allowed in each returned segment. Lines are first filtered by [start_line, end_line], then each line in that range is split into one or more segments of at most max_segment_chars characters. If a line is longer than max_segment_chars, it will be broken up into multiple segments for that same line, with leading/trailing ellipses added to indicate continuation. Use a smaller value (e.g. 1000â€“2000) to avoid overwhelming the LLM context when lines are extremely long.",
    "default": 2000
  },
  "segment_range": {
    "type": "string",
    "example": "1,5",
    "description": "1-based inclusive range of segments to return after splitting the selected lines. The tool first reads lines in [start_line, end_line], splits each line into segments of at most max_segment_chars characters, and numbers these segments from 1 to total_segments in order. segment_range must be a string of the form 'start,end'. For example: '1,5' returns the first 5 segments, '6,10' returns the next 5 segments, and so on. If the requested end index is larger than total_segments, it is clamped to total_segments. Use this to paginate through a large file: first call with '1,5', then inspect total_segments from the output and call again with '6,10', '11,15', etc. If you want to effectively disable pagination for small files, you can set a large range such as '1,1000'.",
    "default": "1,5"
  }
},
  "output_schema": {
    "segments": {
      "type": "array",
      "example": [
        "[line 1] first part of a long line...",
        "[line 1] ...second part of the same long line...",
        "[line 2] a shorter line"
      ],
      "description": "List of formatted segments for the requested range. Long lines may appear as multiple segments with ellipses."
    },
    "total_lines": {
      "type": "integer",
      "example": 1234,
      "description": "Total number of lines in the file."
    },
    "total_segments": {
      "type": "integer",
      "example": 42,
      "description": "Total number of segments produced from the effective line range given max_segment_chars."
    },
    "returned_segment_range": {
      "type": "array",
      "example": [1, 5],
      "description": "The 1-based [start, end] segment indices that were returned (after clamping to available segments)."
    },
    "effective_line_range": {
      "type": "array",
      "example": [1, 200],
      "description": "The [start_line, end_line] actually used after clamping to the total number of lines."
    }
  },
  "scope": ["global"],
  "code": "raise NotImplementedError('Platform overrides are required')",
  "platform_overrides": {
    "linux": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    for line_no in range(start_idx, end_idx + 1):\n        text = lines[line_no - 1]\n        if text is None:\n            text = ''\n        s = text\n        length = len(s)\n        if length == 0:\n            all_segments.append({'line': line_no, 'text': '', 'leading': False, 'trailing': False})\n            continue\n        pos = 0\n        while pos < length:\n            end_pos = min(pos + max_segment_chars, length)\n            chunk = s[pos:end_pos]\n            leading = pos > 0\n            trailing = end_pos < length\n            all_segments.append({'line': line_no, 'text': chunk, 'leading': leading, 'trailing': trailing})\n            pos = end_pos\n\n    total_segments = len(all_segments)\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        t = clean(seg['text'])\n        if not t:\n            display = ''\n        else:\n            display = t\n            if seg.get('leading'):\n                display = '...' + display\n            if seg.get('trailing'):\n                if not display.endswith('...'):\n                    display = display + '...'\n        line_no = seg['line']\n        out_segments.append(f\"[line {line_no}] {display}\")\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    },
    "windows": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    for line_no in range(start_idx, end_idx + 1):\n        text = lines[line_no - 1]\n        if text is None:\n            text = ''\n        s = text\n        length = len(s)\n        if length == 0:\n            all_segments.append({'line': line_no, 'text': '', 'leading': False, 'trailing': False})\n            continue\n        pos = 0\n        while pos < length:\n            end_pos = min(pos + max_segment_chars, length)\n            chunk = s[pos:end_pos]\n            leading = pos > 0\n            trailing = end_pos < length\n            all_segments.append({'line': line_no, 'text': chunk, 'leading': leading, 'trailing': trailing})\n            pos = end_pos\n\n    total_segments = len(all_segments)\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        t = clean(seg['text'])\n        if not t:\n            display = ''\n        else:\n            display = t\n            if seg.get('leading'):\n                display = '...' + display\n            if seg.get('trailing'):\n                if not display.endswith('...'):\n                    display = display + '...'\n        line_no = seg['line']\n        out_segments.append(f\"[line {line_no}] {display}\")\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    },
    "darwin": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    for line_no in range(start_idx, end_idx + 1):\n        text = lines[line_no - 1]\n        if text is None:\n            text = ''\n        s = text\n        length = len(s)\n        if length == 0:\n            all_segments.append({'line': line_no, 'text': '', 'leading': False, 'trailing': False})\n            continue\n        pos = 0\n        while pos < length:\n            end_pos = min(pos + max_segment_chars, length)\n            chunk = s[pos:end_pos]\n            leading = pos > 0\n            trailing = end_pos < length\n            all_segments.append({'line': line_no, 'text': chunk, 'leading': leading, 'trailing': trailing})\n            pos = end_pos\n\n    total_segments = len(all_segments)\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        t = clean(seg['text'])\n        if not t:\n            display = ''\n        else:\n            display = t\n            if seg.get('leading'):\n                display = '...' + display\n            if seg.get('trailing'):\n                if not display.endswith('...'):\n                    display = display + '...'\n        line_no = seg['line']\n        out_segments.append(f\"[line {line_no}] {display}\")\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    }
  }
}
