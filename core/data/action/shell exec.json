{
  "_id": { "$oid": "68b6ad213aa5a3e9d9026a13" },
  "name": "shell exec",
  "description": "Executes a shell command using the appropriate OS shell, capturing stdout, stderr, and exit code. Stdin is closed (EOF) by default and no input can be provided by the agent when prompted by shell.",
  "type": "atomic",
  "execution_mode": "sandboxed",
  "platforms": ["windows", "linux", "darwin"],
  "input_schema": {
    "command": {
      "type": "string",
      "example": "dir C:\\\\Windows\\\\System32",
      "description": "The shell command to execute."
    },
    "shell": {
      "type": "string",
      "example": "auto",
      "description": "Shell to use. Default is platform's native shell (cmd, bash, or zsh)."
    },
    "timeout": {
      "type": "integer",
      "example": 60,
      "description": "Optional timeout (seconds). If exceeded, the process is terminated."
    },
    "cwd": {
      "type": "string",
      "example": "/home/user",
      "description": "Optional working directory for the command."
    },
    "env": {
      "type": "object",
      "additionalProperties": { "type": "string" },
      "example": { "MY_VAR": "123" },
      "description": "Optional environment variable overrides."
    }
  },
  "output_schema": {
    "status": { "type": "string", "example": "success" },
    "stdout": { "type": "string", "example": "Command output text" },
    "stderr": { "type": "string", "example": "" },
    "return_code": { "type": "integer", "example": 0 },
    "message": { "type": "string", "example": "Timed out after 30s." }
  },
  "scope": ["global"],

  "code": "import os, json, subprocess\n\ncommand = str(input_data.get('command', '')).strip()\nshell_choice = str(input_data.get('shell', 'auto')).strip().lower()\ntimeout_val = input_data.get('timeout')\ncwd = input_data.get('cwd')\nenv_input = input_data.get('env') or {}\n\ntimeout_seconds = float(timeout_val) if timeout_val is not None else 30.0\n\nif not command:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'command is required.'})\n    raise SystemExit()\n\nif cwd and not os.path.isdir(cwd):\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'Working directory does not exist.'})\n    raise SystemExit()\n\nenv = os.environ.copy()\nfor k, v in env_input.items():\n    env[str(k)] = str(v)\n\nrun_kwargs = {\n    'capture_output': True,\n    'text': True,\n    'errors': 'replace',\n    'cwd': cwd if cwd else None,\n    'env': env,\n    'timeout': timeout_seconds,\n    'stdin': subprocess.DEVNULL,\n    'shell': True,\n}\n\ntry:\n    # Default: use system shell (sh)\n    result = subprocess.run(\n        command,\n        **run_kwargs\n    )\n    output = json.dumps({\n        'status': 'success' if result.returncode == 0 else 'error',\n        'stdout': result.stdout.strip(),\n        'stderr': result.stderr.strip(),\n        'return_code': result.returncode,\n        'message': ''\n    })\nexcept subprocess.TimeoutExpired as e:\n    output = json.dumps({'status': 'error', 'stdout': (e.stdout or '').strip(), 'stderr': (e.stderr or '').strip(), 'return_code': -1, 'message': f'Timed out after {timeout_seconds}s.'})\nexcept Exception as e:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': str(e), 'return_code': -1, 'message': str(e)})",

  "platform_overrides": {
    "windows": {
      "code": "import os, json, subprocess\n\ncommand = str(input_data.get('command', '')).strip()\nshell_choice = str(input_data.get('shell', 'cmd')).strip().lower()\ntimeout_val = input_data.get('timeout')\ncwd = input_data.get('cwd')\nenv_input = input_data.get('env') or {}\n\ntimeout_seconds = float(timeout_val) if timeout_val is not None else 30.0\n\nif not command:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'command is required.'})\n    raise SystemExit()\n\nif cwd and not os.path.isdir(cwd):\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'Working directory does not exist.'})\n    raise SystemExit()\n\nenv = os.environ.copy()\nfor k, v in env_input.items():\n    env[str(k)] = str(v)\n\nif shell_choice == 'powershell':\n    args = ['powershell.exe', '-NoLogo', '-NonInteractive', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', command]\nelif shell_choice == 'pwsh':\n    args = ['pwsh.exe', '-NoLogo', '-NonInteractive', '-NoProfile', '-Command', command]\nelse:\n    args = ['cmd.exe', '/c', command]\n\nrun_kwargs = {\n    'capture_output': True,\n    'text': True,\n    'errors': 'replace',\n    'cwd': cwd if cwd else None,\n    'env': env,\n    'timeout': timeout_seconds,\n    'creationflags': getattr(subprocess, 'CREATE_NO_WINDOW', 0),\n    'stdin': subprocess.DEVNULL,\n}\n\ntry:\n    result = subprocess.run(\n        args,\n        **run_kwargs\n    )\n    output = json.dumps({\n        'status': 'success' if result.returncode == 0 else 'error',\n        'stdout': result.stdout.strip(),\n        'stderr': result.stderr.strip(),\n        'return_code': result.returncode,\n        'message': ''\n    })\nexcept subprocess.TimeoutExpired as e:\n    output = json.dumps({'status': 'error', 'stdout': (e.stdout or '').strip(), 'stderr': (e.stderr or '').strip(), 'return_code': -1, 'message': f'Timed out after {timeout_seconds}s.'})\nexcept Exception as e:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': str(e), 'return_code': -1, 'message': str(e)})"
    },
    "darwin": {
      "code": "import os, json, subprocess\n\ncommand = str(input_data.get('command', '')).strip()\nshell_choice = str(input_data.get('shell', 'bash')).strip().lower()\ntimeout_val = input_data.get('timeout')\ncwd = input_data.get('cwd')\nenv_input = input_data.get('env') or {}\n\ntimeout_seconds = float(timeout_val) if timeout_val is not None else 30.0\n\nif not command:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'command is required.'})\n    raise SystemExit()\n\nif cwd and not os.path.isdir(cwd):\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': '', 'return_code': -1, 'message': 'Working directory does not exist.'})\n    raise SystemExit()\n\nenv = os.environ.copy()\nfor k, v in env_input.items():\n    env[str(k)] = str(v)\n\nargs = ['/bin/zsh', '-c', command] if shell_choice == 'zsh' else ['/bin/bash', '-c', command]\n\nrun_kwargs = {\n    'capture_output': True,\n    'text': True,\n    'errors': 'replace',\n    'cwd': cwd if cwd else None,\n    'env': env,\n    'timeout': timeout_seconds,\n    'stdin': subprocess.DEVNULL,\n}\n\ntry:\n    result = subprocess.run(\n        args,\n        **run_kwargs\n    )\n    output = json.dumps({\n        'status': 'success' if result.returncode == 0 else 'error',\n        'stdout': result.stdout.strip(),\n        'stderr': result.stderr.strip(),\n        'return_code': result.returncode,\n        'message': ''\n    })\nexcept subprocess.TimeoutExpired as e:\n    output = json.dumps({'status': 'error', 'stdout': (e.stdout or '').strip(), 'stderr': (e.stderr or '').strip(), 'return_code': -1, 'message': f'Timed out after {timeout_seconds}s.'})\nexcept Exception as e:\n    output = json.dumps({'status': 'error', 'stdout': '', 'stderr': str(e), 'return_code': -1, 'message': str(e)})"
    }
  }
}
