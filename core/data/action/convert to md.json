{
  "_id": { "$oid": "68627c3ac6ce8cf75ea8000" },
  "name": "clean_to_md",
  "description": "Cleans scraped text from .txt, .md, or .docx and converts it into clean, well-structured Markdown suitable for PDF conversion.",
  "type": "atomic",
  "execution_mode": "sandboxed",
  "mode": "ALL",
  "platforms": ["linux", "windows", "darwin"],
  "input_schema": {
    "input_file": {
      "type": "string",
      "example": "/path/to/input.txt",
      "description": "Path to the input file (txt, md, docx)."
    },
    "output_md": {
      "type": "string",
      "example": "/path/to/output.md",
      "description": "Path where the cleaned Markdown file will be saved."
    }
  },
  "output_schema": {
    "md_file": {
      "type": "string",
      "example": "/path/to/output.md",
      "description": "Path to the generated Markdown file."
    }
  },
  "code": "import os, sys, json, subprocess, importlib, re\n\n# Ensure required libraries\nfor pkg in ['python-docx']:\n    try:\n        importlib.import_module(pkg.replace('-', '_'))\n    except ImportError:\n        subprocess.check_call([sys.executable, '-m', 'pip', 'install', pkg, '--quiet'])\n\nfrom docx import Document\n\ndef read_input_file(path):\n    ext = os.path.splitext(path)[1].lower()\n    if ext in ['.txt', '.md']:\n        with open(path, 'r', encoding='utf-8', errors='ignore') as f:\n            return f.read()\n    if ext == '.docx':\n        doc = Document(path)\n        return '\\n'.join(p.text for p in doc.paragraphs)\n    raise ValueError('Unsupported input file type.')\n\ndef normalize_headings(text):\n    # Convert lines in ALL CAPS into Markdown H2\n    lines = text.split('\\n')\n    out = []\n    for line in lines:\n        stripped = line.strip()\n        if stripped.isupper() and len(stripped.split()) <= 6:\n            out.append('## ' + stripped)\n        else:\n            out.append(line)\n    return '\\n'.join(out)\n\ndef fix_lists(text):\n    # Clean bullet points like '-', '*', '•'\n    text = re.sub(r'^[\\s]*[\\-*•][\\s]+', '- ', text, flags=re.MULTILINE)\n    # Fix numbered lists\n    text = re.sub(r'^[\\s]*\\d+[\\.)]\\s+', lambda m: f\"{m.group(0).strip()} \", text, flags=re.MULTILINE)\n    return text\n\ndef clean_text(text):\n    # Remove inline references [1], [2]\n    text = re.sub(r'\\[\\d+\\]', '', text)\n    # Remove URLs inside brackets e.g. [src]\n    text = re.sub(r'\\[[^\\]]*?src[^\\]]*?\\]', '', text, flags=re.IGNORECASE)\n    # Remove extra spaces\n    text = re.sub(r' {2,}', ' ', text)\n    # Remove non-ASCII artifacts\n    text = re.sub(r'[^\\x00-\\x7F]+', '', text)\n    # Merge single line breaks into spacing\n    text = re.sub(r'(?<!\\n)\\n(?!\\n)', ' ', text)\n    # Ensure blank line between paragraphs\n    text = re.sub(r'\\n\\s*\\n', '\\n\\n', text)\n    text = normalize_headings(text)\n    text = fix_lists(text)\n    return text.strip() + '\\n'\n\ndef save_as_md(cleaned_text, output_path):\n    os.makedirs(os.path.dirname(output_path), exist_ok=True)\n    with open(output_path, 'w', encoding='utf-8') as f:\n        f.write(cleaned_text)\n    return output_path\n\ntry:\n    input_file = input_data.get('input_file')\n    output_md = input_data.get('output_md')\n\n    if not input_file or not os.path.isfile(input_file):\n        output = json.dumps({'error': 'Valid input_file required.'})\n    else:\n        if not output_md:\n            base, _ = os.path.splitext(input_file)\n            output_md = base + '_clean.md'\n\n        raw_text = read_input_file(input_file)\n        cleaned_text = clean_text(raw_text)\n        result = save_as_md(cleaned_text, output_md)\n        output = json.dumps({'md_file': result})\nexcept Exception as e:\n    output = json.dumps({'error': str(e)})"
}
