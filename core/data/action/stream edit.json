{
  "_id": { "$oid": "68b6ad213aa5a3e9d9026b9e" },
  "name": "stream edit",
  "description": "Applies a regex-based edit to a slice of lines in a text file, returning paginated original and edited segments. Similar to sed with paging.",
  "type": "atomic",
  "execution_mode": "sandboxed",
  "mode": "CLI",
  "platforms": ["windows", "linux", "darwin"],
"input_schema": {
  "input_file": {
    "type": "string",
    "example": "/path/to/file.txt",
    "description": "Absolute or relative path to the input text file to inspect and virtually edit. The file must already exist on disk and be readable as UTF-8 text. This action does NOT modify the file on disk; it only returns what the edited text would look like in the specified region."
  },
  "start_line": {
    "type": "integer",
    "example": 1,
    "description": "1-based start line number (inclusive) on which to apply edits. Only lines in the range [start_line, end_line] are considered for regex substitution and segment generation. If start_line is less than 1, it is treated as 1. If start_line is larger than the total number of lines, it is clamped to the last line.",
    "default": 1
  },
  "end_line": {
    "type": "integer",
    "example": 200,
    "description": "1-based end line number (inclusive) on which to apply edits. If end_line is less than 1, it is treated as 1. If end_line is larger than the total number of lines, it is clamped to the last line. If end_line < start_line, the two values are swapped internally so the effective range is always from the smaller to the larger line number. Only lines in this final [start_line, end_line] range are edited and turned into segments.",
    "default": 200
  },
  "pattern": {
    "type": "string",
    "example": "foo",
    "description": "Regular expression pattern (Python re syntax) to search for within each line of the effective [start_line, end_line] range. This is required: if pattern is missing or empty, the action will raise an error. The regex is applied to each line independently, and only lines where the pattern matches at least once are included in the output."
  },
  "replacement": {
    "type": "string",
    "example": "bar",
    "description": "Replacement string used in the regex substitution. The action effectively performs re.sub(pattern, replacement, line_text) for each line in the effective range. If replacement is omitted, it defaults to the empty string, meaning that matched content will be removed. The output includes both the original and edited versions of each affected line so the agent can compare them."
  },
  "max_segment_chars": {
    "type": "integer",
    "example": 2000,
    "description": "Maximum number of characters allowed in each returned segment pair. After editing, each affected line (original and edited) is split into segments of at most max_segment_chars characters. Very long lines will therefore produce multiple segments for the same line, each showing a slice of the original text and the corresponding slice of the edited text. Use smaller values (e.g. 1000â€“4000) to avoid returning overly large segments when working with extremely long lines.",
    "default": 2000
  },
  "segment_range": {
    "type": "string",
    "example": "1,5",
    "description": "1-based inclusive range of segments to return after editing and splitting. After applying the regex to all lines in [start_line, end_line], the action creates segments from each edited line and numbers them from 1 to total_segments in order. segment_range must be a string of the form 'start,end'. For example: '1,5' returns the first 5 segment pairs; '6,10' returns the next 5 segment pairs, and so on. If the requested end index exceeds total_segments, it is clamped. Agents should use this field to paginate through edits, e.g. first call with '1,5', then '6,10', etc., instead of requesting all segments at once in large files.",
    "default": "1,5"
  }
},
  "output_schema": {
    "segments": {
      "type": "array",
      "example": [
        "[line 10] original: The quick brown fox...\n[line 10] edited  : The fast brown fox...",
        "[line 10] original: ...jumps over the lazy dog\n[line 10] edited  : ...leaps over the lazy dog"
      ],
      "description": "List of formatted segments for the requested range. Each segment shows both original and edited text for that slice of a line."
    },
    "total_lines": {
      "type": "integer",
      "example": 1234,
      "description": "Total number of lines in the file."
    },
    "total_segments": {
      "type": "integer",
      "example": 42,
      "description": "Total number of segments produced from the effective line range given max_segment_chars."
    },
    "total_edited_lines": {
      "type": "integer",
      "example": 7,
      "description": "Number of lines in the effective line range that were actually changed by the edit."
    },
    "returned_segment_range": {
      "type": "array",
      "example": [1, 5],
      "description": "The 1-based [start, end] segment indices that were returned (after clamping to available segments)."
    },
    "effective_line_range": {
      "type": "array",
      "example": [1, 200],
      "description": "The [start_line, end_line] actually used after clamping to the total number of lines."
    }
  },
  "scope": ["global"],
  "code": "raise NotImplementedError('Platform overrides are required')",
  "platform_overrides": {
    "linux": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    pattern = input_data.get('pattern')\n    replacement = input_data.get('replacement', '')\n    if not pattern:\n        raise ValueError('pattern must be provided for stream edit.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'total_edited_lines': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    edited_line_count = 0\n\n    for line_no in range(start_idx, end_idx + 1):\n        original = lines[line_no - 1]\n        if original is None:\n            original = ''\n        edited = re.sub(pattern, replacement, original)\n        if edited == original:\n            continue\n        edited_line_count += 1\n        max_len = max(len(original), len(edited))\n        if max_len == 0:\n            continue\n        pos = 0\n        while pos < max_len:\n            end_pos = min(pos + max_segment_chars, max_len)\n            orig_chunk = original[pos:end_pos]\n            edit_chunk = edited[pos:end_pos]\n            leading = pos > 0\n            trailing_orig = end_pos < len(original)\n            trailing_edit = end_pos < len(edited)\n            trailing = trailing_orig or trailing_edit\n            all_segments.append({\n                'line': line_no,\n                'orig': orig_chunk,\n                'edit': edit_chunk,\n                'leading': leading,\n                'trailing': trailing\n            })\n            pos = end_pos\n\n    total_segments = len(all_segments)\n\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'total_edited_lines': edited_line_count,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        o = clean(seg['orig'])\n        e = clean(seg['edit'])\n        if o:\n            o_disp = o\n            if seg.get('leading'):\n                o_disp = '...' + o_disp\n            if seg.get('trailing') and not o_disp.endswith('...'):\n                o_disp = o_disp + '...'\n        else:\n            o_disp = ''\n        if e:\n            e_disp = e\n            if seg.get('leading'):\n                e_disp = '...' + e_disp\n            if seg.get('trailing') and not e_disp.endswith('...'):\n                e_disp = e_disp + '...'\n        else:\n            e_disp = ''\n        line_no = seg['line']\n        combined = f\"[line {line_no}] original: {o_disp}\\n[line {line_no}] edited  : {e_disp}\"\n        out_segments.append(combined)\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'total_edited_lines': edited_line_count,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    },
    "windows": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    pattern = input_data.get('pattern')\n    replacement = input_data.get('replacement', '')\n    if not pattern:\n        raise ValueError('pattern must be provided for stream edit.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'total_edited_lines': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    edited_line_count = 0\n\n    for line_no in range(start_idx, end_idx + 1):\n        original = lines[line_no - 1]\n        if original is None:\n            original = ''\n        edited = re.sub(pattern, replacement, original)\n        if edited == original:\n            continue\n        edited_line_count += 1\n        max_len = max(len(original), len(edited))\n        if max_len == 0:\n            continue\n        pos = 0\n        while pos < max_len:\n            end_pos = min(pos + max_segment_chars, max_len)\n            orig_chunk = original[pos:end_pos]\n            edit_chunk = edited[pos:end_pos]\n            leading = pos > 0\n            trailing_orig = end_pos < len(original)\n            trailing_edit = end_pos < len(edited)\n            trailing = trailing_orig or trailing_edit\n            all_segments.append({\n                'line': line_no,\n                'orig': orig_chunk,\n                'edit': edit_chunk,\n                'leading': leading,\n                'trailing': trailing\n            })\n            pos = end_pos\n\n    total_segments = len(all_segments)\n\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'total_edited_lines': edited_line_count,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        o = clean(seg['orig'])\n        e = clean(seg['edit'])\n        if o:\n            o_disp = o\n            if seg.get('leading'):\n                o_disp = '...' + o_disp\n            if seg.get('trailing') and not o_disp.endswith('...'):\n                o_disp = o_disp + '...'\n        else:\n            o_disp = ''\n        if e:\n            e_disp = e\n            if seg.get('leading'):\n                e_disp = '...' + e_disp\n            if seg.get('trailing') and not e_disp.endswith('...'):\n                e_disp = e_disp + '...'\n        else:\n            e_disp = ''\n        line_no = seg['line']\n        combined = f\"[line {line_no}] original: {o_disp}\\n[line {line_no}] edited  : {e_disp}\"\n        out_segments.append(combined)\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'total_edited_lines': edited_line_count,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    },
    "darwin": {
      "code": "import os, json, sys, asyncio, re\n\nasync def main():\n    input_file = input_data.get('input_file')\n    if not input_file or not os.path.isfile(input_file):\n        raise ValueError('Input file must exist.')\n\n    pattern = input_data.get('pattern')\n    replacement = input_data.get('replacement', '')\n    if not pattern:\n        raise ValueError('pattern must be provided for stream edit.')\n\n    try:\n        start_line = int(input_data.get('start_line', 1))\n    except Exception:\n        start_line = 1\n    try:\n        end_line = int(input_data.get('end_line', 200))\n    except Exception:\n        end_line = start_line\n\n    try:\n        max_segment_chars = int(input_data.get('max_segment_chars', 2000))\n    except Exception:\n        max_segment_chars = 2000\n\n    segment_range_str = input_data.get('segment_range', '1,5')\n    try:\n        start_seg_str, end_seg_str = [s.strip() for s in str(segment_range_str).split(',', 1)]\n        start_seg = int(start_seg_str)\n        end_seg = int(end_seg_str)\n    except Exception:\n        start_seg, end_seg = 1, 5\n\n    if start_line < 1:\n        start_line = 1\n    if end_line < 1:\n        end_line = 1\n    if end_line < start_line:\n        start_line, end_line = end_line, start_line\n\n    if max_segment_chars <= 0:\n        max_segment_chars = 2000\n\n    if start_seg < 1:\n        start_seg = 1\n    if end_seg < 1:\n        end_seg = 1\n    if end_seg < start_seg:\n        start_seg, end_seg = end_seg, start_seg\n\n    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f:\n        lines = f.read().splitlines()\n\n    total_lines = len(lines)\n\n    if total_lines == 0:\n        result = {\n            'segments': [],\n            'total_lines': 0,\n            'total_segments': 0,\n            'total_edited_lines': 0,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [0, 0]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_idx = max(1, min(start_line, total_lines))\n    end_idx = max(1, min(end_line, total_lines))\n    if end_idx < start_idx:\n        start_idx, end_idx = end_idx, start_idx\n\n    all_segments = []\n    edited_line_count = 0\n\n    for line_no in range(start_idx, end_idx + 1):\n        original = lines[line_no - 1]\n        if original is None:\n            original = ''\n        edited = re.sub(pattern, replacement, original)\n        if edited == original:\n            continue\n        edited_line_count += 1\n        max_len = max(len(original), len(edited))\n        if max_len == 0:\n            continue\n        pos = 0\n        while pos < max_len:\n            end_pos = min(pos + max_segment_chars, max_len)\n            orig_chunk = original[pos:end_pos]\n            edit_chunk = edited[pos:end_pos]\n            leading = pos > 0\n            trailing_orig = end_pos < len(original)\n            trailing_edit = end_pos < len(edited)\n            trailing = trailing_orig or trailing_edit\n            all_segments.append({\n                'line': line_no,\n                'orig': orig_chunk,\n                'edit': edit_chunk,\n                'leading': leading,\n                'trailing': trailing\n            })\n            pos = end_pos\n\n    total_segments = len(all_segments)\n\n    if total_segments == 0:\n        result = {\n            'segments': [],\n            'total_lines': total_lines,\n            'total_segments': 0,\n            'total_edited_lines': edited_line_count,\n            'returned_segment_range': [start_seg, end_seg],\n            'effective_line_range': [start_idx, end_idx]\n        }\n        output = (json.dumps(result))\n        return\n\n    start_seg_clamped = max(1, min(start_seg, total_segments))\n    end_seg_clamped = max(1, min(end_seg, total_segments))\n    if end_seg_clamped < start_seg_clamped:\n        start_seg_clamped, end_seg_clamped = end_seg_clamped, start_seg_clamped\n\n    selected = all_segments[start_seg_clamped - 1:end_seg_clamped]\n\n    def clean(s):\n        s = s.strip()\n        s = re.sub(r'\\s+', ' ', s)\n        return s\n\n    out_segments = []\n    for seg in selected:\n        o = clean(seg['orig'])\n        e = clean(seg['edit'])\n        if o:\n            o_disp = o\n            if seg.get('leading'):\n                o_disp = '...' + o_disp\n            if seg.get('trailing') and not o_disp.endswith('...'):\n                o_disp = o_disp + '...'\n        else:\n            o_disp = ''\n        if e:\n            e_disp = e\n            if seg.get('leading'):\n                e_disp = '...' + e_disp\n            if seg.get('trailing') and not e_disp.endswith('...'):\n                e_disp = e_disp + '...'\n        else:\n            e_disp = ''\n        line_no = seg['line']\n        combined = f\"[line {line_no}] original: {o_disp}\\n[line {line_no}] edited  : {e_disp}\"\n        out_segments.append(combined)\n\n    result = {\n        'segments': out_segments,\n        'total_lines': total_lines,\n        'total_segments': total_segments,\n        'total_edited_lines': edited_line_count,\n        'returned_segment_range': [start_seg_clamped, end_seg_clamped],\n        'effective_line_range': [start_idx, end_idx]\n    }\n\n    output = (json.dumps(result))\n\nasyncio.run(main())"
    }
  }
}
